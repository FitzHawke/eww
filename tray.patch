From e489c10559fef84729776a89329bdbf53b1807a4 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Mon, 20 Mar 2023 23:24:21 +1100
Subject: [PATCH 01/30] Allow tokio on gtk thread

---
 crates/eww/src/server.rs | 22 ++++++++++++++--------
 1 file changed, 14 insertions(+), 8 deletions(-)

diff --git a/crates/eww/src/server.rs b/crates/eww/src/server.rs
index 5b557fa4..4ad611b7 100644
--- a/crates/eww/src/server.rs
+++ b/crates/eww/src/server.rs
@@ -98,7 +98,7 @@ pub fn initialize_server<B: DisplayBackend>(
     }
 
     // initialize all the handlers and tasks running asyncronously
-    init_async_part(app.paths.clone(), ui_send);
+    let tokio_handle = init_async_part(app.paths.clone(), ui_send);
 
     glib::MainContext::default().spawn_local(async move {
         // if an action was given to the daemon initially, execute it first.
@@ -119,22 +119,26 @@ pub fn initialize_server<B: DisplayBackend>(
         }
     });
 
+    // allow the GTK main thread to do tokio things
+    let _g = tokio_handle.enter();
+
     gtk::main();
     log::info!("main application thread finished");
 
     Ok(ForkResult::Child)
 }
 
-fn init_async_part(paths: EwwPaths, ui_send: UnboundedSender<app::DaemonCommand>) {
+fn init_async_part(paths: EwwPaths, ui_send: UnboundedSender<app::DaemonCommand>) -> tokio::runtime::Handle {
+    let rt = tokio::runtime::Builder::new_multi_thread()
+        .thread_name("main-async-runtime")
+        .enable_all()
+        .build()
+        .expect("Failed to initialize tokio runtime");
+    let handle = rt.handle().clone();
+
     std::thread::Builder::new()
         .name("outer-main-async-runtime".to_string())
         .spawn(move || {
-            let rt = tokio::runtime::Builder::new_multi_thread()
-                .thread_name("main-async-runtime")
-                .enable_all()
-                .build()
-                .expect("Failed to initialize tokio runtime");
-
             rt.block_on(async {
                 let filewatch_join_handle = {
                     let ui_send = ui_send.clone();
@@ -166,6 +170,8 @@ fn init_async_part(paths: EwwPaths, ui_send: UnboundedSender<app::DaemonCommand>
             })
         })
         .expect("Failed to start outer-main-async-runtime thread");
+
+    handle
 }
 
 /// Watch configuration files for changes, sending reload events to the eww app when the files change.

From c04faa2c4d6c9dd5607398697e9c94f8ab2584e3 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Tue, 13 Jun 2023 10:40:15 +1000
Subject: [PATCH 02/30] Basic notifier host implementation

---
 Cargo.lock                                    | 560 +++++++++++++++++-
 crates/notifier_host/Cargo.toml               |  16 +
 crates/notifier_host/src/dbus/dbus_menu.xml   |  69 +++
 .../src/dbus/dbus_status_notifier_item.rs     | 111 ++++
 .../src/dbus/dbus_status_notifier_item.xml    |  49 ++
 .../src/dbus/dbus_status_notifier_watcher.rs  |  53 ++
 .../src/dbus/dbus_status_notifier_watcher.xml |  52 ++
 crates/notifier_host/src/dbus/mod.rs          |  11 +
 crates/notifier_host/src/error.rs             |  11 +
 crates/notifier_host/src/host.rs              |  65 ++
 crates/notifier_host/src/item.rs              | 195 ++++++
 crates/notifier_host/src/lib.rs               |  10 +
 12 files changed, 1196 insertions(+), 6 deletions(-)
 create mode 100644 crates/notifier_host/Cargo.toml
 create mode 100644 crates/notifier_host/src/dbus/dbus_menu.xml
 create mode 100644 crates/notifier_host/src/dbus/dbus_status_notifier_item.rs
 create mode 100644 crates/notifier_host/src/dbus/dbus_status_notifier_item.xml
 create mode 100644 crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs
 create mode 100644 crates/notifier_host/src/dbus/dbus_status_notifier_watcher.xml
 create mode 100644 crates/notifier_host/src/dbus/mod.rs
 create mode 100644 crates/notifier_host/src/error.rs
 create mode 100644 crates/notifier_host/src/host.rs
 create mode 100644 crates/notifier_host/src/item.rs
 create mode 100644 crates/notifier_host/src/lib.rs

diff --git a/Cargo.lock b/Cargo.lock
index ee71ec84..4e6ebdc4 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -61,6 +61,91 @@ dependencies = [
  "term",
 ]
 
+[[package]]
+name = "async-broadcast"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7c48ccdbf6ca6b121e0f586cbc0e73ae440e56c67c30fa0873b4e110d9c26d2b"
+dependencies = [
+ "event-listener",
+ "futures-core",
+]
+
+[[package]]
+name = "async-channel"
+version = "1.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf46fee83e5ccffc220104713af3292ff9bc7c64c7de289f66dae8e38d826833"
+dependencies = [
+ "concurrent-queue",
+ "event-listener",
+ "futures-core",
+]
+
+[[package]]
+name = "async-io"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fc5b45d93ef0529756f812ca52e44c221b35341892d3dcc34132ac02f3dd2af"
+dependencies = [
+ "async-lock",
+ "autocfg",
+ "cfg-if",
+ "concurrent-queue",
+ "futures-lite",
+ "log",
+ "parking",
+ "polling",
+ "rustix 0.37.7",
+ "slab",
+ "socket2",
+ "waker-fn",
+]
+
+[[package]]
+name = "async-lock"
+version = "2.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa24f727524730b077666307f2734b4a1a1c57acb79193127dcc8914d5242dd7"
+dependencies = [
+ "event-listener",
+]
+
+[[package]]
+name = "async-process"
+version = "1.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a9d28b1d97e08915212e2e45310d47854eafa69600756fc735fb788f75199c9"
+dependencies = [
+ "async-io",
+ "async-lock",
+ "autocfg",
+ "blocking",
+ "cfg-if",
+ "event-listener",
+ "futures-lite",
+ "rustix 0.37.7",
+ "signal-hook",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
+name = "async-recursion"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e97ce7de6cf12de5d7226c73f5ba9811622f4db3a5b91b55c53e987e5f91cba"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.10",
+]
+
+[[package]]
+name = "async-task"
+version = "4.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ecc7ab41815b3c653ccd2978ec3255c81349336702dfdf62ee6f7069b12a3aae"
+
 [[package]]
 name = "async-trait"
 version = "0.1.64"
@@ -102,6 +187,12 @@ dependencies = [
  "system-deps",
 ]
 
+[[package]]
+name = "atomic-waker"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1181e1e0d1fce796a03db1ae795d67167da795f9cf4a39c37589e85ef57f26d3"
+
 [[package]]
 name = "atty"
 version = "0.2.14"
@@ -149,12 +240,42 @@ version = "1.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
 
+[[package]]
+name = "block-buffer"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
+name = "blocking"
+version = "1.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77231a1c8f801696fc0123ec6150ce92cffb8e164a02afb9c8ddee0e9b65ad65"
+dependencies = [
+ "async-channel",
+ "async-lock",
+ "async-task",
+ "atomic-waker",
+ "fastrand",
+ "futures-lite",
+ "log",
+]
+
 [[package]]
 name = "bumpalo"
 version = "3.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a3e2c3daef883ecc1b5d58c15adae93470a91d425f3532ba1695849656af3fc1"
 
+[[package]]
+name = "byteorder"
+version = "1.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"
+
 [[package]]
 name = "bytes"
 version = "1.2.1"
@@ -342,6 +463,15 @@ dependencies = [
  "unicode-width",
 ]
 
+[[package]]
+name = "concurrent-queue"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "62ec6771ecfa0762d24683ee5a32ad78487a3d3afdc0fb8cae19d2c5deb50b7c"
+dependencies = [
+ "crossbeam-utils",
+]
+
 [[package]]
 name = "console"
 version = "0.15.2"
@@ -389,6 +519,15 @@ version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5827cebf4670468b8772dd191856768aedcb1b0278a04f989f7766351917b9dc"
 
+[[package]]
+name = "cpufeatures"
+version = "0.2.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3e4c1eaa2012c47becbbad2ab175484c2a84d1185b566fb2cc5b8707343dfe58"
+dependencies = [
+ "libc",
+]
+
 [[package]]
 name = "crossbeam-channel"
 version = "0.5.6"
@@ -438,6 +577,16 @@ version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"
 
+[[package]]
+name = "crypto-common"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
+dependencies = [
+ "generic-array",
+ "typenum",
+]
+
 [[package]]
 name = "ctor"
 version = "0.1.26"
@@ -483,6 +632,17 @@ dependencies = [
  "syn 1.0.103",
 ]
 
+[[package]]
+name = "derivative"
+version = "2.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.103",
+]
+
 [[package]]
 name = "derive_more"
 version = "0.99.17"
@@ -502,6 +662,16 @@ version = "0.1.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8"
 
+[[package]]
+name = "digest"
+version = "0.10.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
+dependencies = [
+ "block-buffer",
+ "crypto-common",
+]
+
 [[package]]
 name = "dirs-next"
 version = "2.0.0"
@@ -550,6 +720,27 @@ version = "0.3.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f"
 
+[[package]]
+name = "enumflags2"
+version = "0.7.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c041f5090df68b32bcd905365fd51769c8b9d553fe87fde0b683534f10c01bd2"
+dependencies = [
+ "enumflags2_derive",
+ "serde",
+]
+
+[[package]]
+name = "enumflags2_derive"
+version = "0.7.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5e9a1f9f7d83e59740248a6e14ecf93929ade55027844dfcea78beafccc15745"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.10",
+]
+
 [[package]]
 name = "env_logger"
 version = "0.7.1"
@@ -574,6 +765,17 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "errno"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4bcfec3a70f97c962c307b2d2c56e358cf1d00b558d74262b5f929ee8cc7e73a"
+dependencies = [
+ "errno-dragonfly",
+ "libc",
+ "windows-sys 0.48.0",
+]
+
 [[package]]
 name = "errno-dragonfly"
 version = "0.1.2"
@@ -584,6 +786,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "event-listener"
+version = "2.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"
+
 [[package]]
 name = "eww"
 version = "0.4.0"
@@ -649,6 +857,15 @@ dependencies = [
  "syn 2.0.10",
 ]
 
+[[package]]
+name = "fastrand"
+version = "1.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
+dependencies = [
+ "instant",
+]
+
 [[package]]
 name = "field-offset"
 version = "0.3.4"
@@ -667,7 +884,7 @@ checksum = "4b9663d381d07ae25dc88dbdf27df458faa83a9b25336bcac83d5e452b5fc9d3"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "windows-sys 0.42.0",
 ]
 
@@ -739,6 +956,21 @@ version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "00f5fb52a06bdcadeb54e8d3671f8888a39697dcb0b81b23b55174030427f4eb"
 
+[[package]]
+name = "futures-lite"
+version = "1.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49a9d51ce47660b1e808d3c990b4709f2f415d928835a17dfd16991515c46bce"
+dependencies = [
+ "fastrand",
+ "futures-core",
+ "futures-io",
+ "memchr",
+ "parking",
+ "pin-project-lite",
+ "waker-fn",
+]
+
 [[package]]
 name = "futures-macro"
 version = "0.3.27"
@@ -863,6 +1095,16 @@ dependencies = [
  "x11",
 ]
 
+[[package]]
+name = "generic-array"
+version = "0.14.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
+dependencies = [
+ "typenum",
+ "version_check",
+]
+
 [[package]]
 name = "gethostname"
 version = "0.2.3"
@@ -1117,6 +1359,12 @@ version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286"
 
+[[package]]
+name = "hex"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
+
 [[package]]
 name = "humantime"
 version = "1.3.0"
@@ -1225,7 +1473,7 @@ checksum = "8687c819457e979cc940d09cb16e42a1bf70aa6b60a549de6d3a62a0ee90c69e"
 dependencies = [
  "hermit-abi 0.3.1",
  "io-lifetimes",
- "rustix",
+ "rustix 0.36.11",
  "windows-sys 0.45.0",
 ]
 
@@ -1374,6 +1622,12 @@ version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8f9f08d8963a6c613f4b1a78f4f4a4dbfadf8e6545b2d72861731e4858b8b47f"
 
+[[package]]
+name = "linux-raw-sys"
+version = "0.3.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"
+
 [[package]]
 name = "lock_api"
 version = "0.4.9"
@@ -1468,6 +1722,17 @@ dependencies = [
  "static_assertions",
 ]
 
+[[package]]
+name = "notifier_host"
+version = "0.1.0"
+dependencies = [
+ "gtk",
+ "log",
+ "thiserror",
+ "tokio",
+ "zbus",
+]
+
 [[package]]
 name = "notify"
 version = "5.1.0"
@@ -1520,6 +1785,16 @@ version = "1.17.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3"
 
+[[package]]
+name = "ordered-stream"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9aa2b01e1d916879f73a53d01d1d6cee68adbb31d6d9177a8cfce093cced1d50"
+dependencies = [
+ "futures-core",
+ "pin-project-lite",
+]
+
 [[package]]
 name = "os_str_bytes"
 version = "6.3.0"
@@ -1560,6 +1835,12 @@ dependencies = [
  "system-deps",
 ]
 
+[[package]]
+name = "parking"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "14f2252c834a40ed9bb5422029649578e63aa341ac401f74e719dd1afda8394e"
+
 [[package]]
 name = "parking_lot"
 version = "0.12.1"
@@ -1578,7 +1859,7 @@ checksum = "4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "smallvec",
  "windows-sys 0.42.0",
 ]
@@ -1718,6 +1999,22 @@ version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1df8c4ec4b0627e53bdf214615ad287367e482558cf84b109250b37464dc03ae"
 
+[[package]]
+name = "polling"
+version = "2.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4b2d323e8ca7996b3e23126511a523f7e62924d93ecd5ae73b333815b0eb3dce"
+dependencies = [
+ "autocfg",
+ "bitflags",
+ "cfg-if",
+ "concurrent-queue",
+ "libc",
+ "log",
+ "pin-project-lite",
+ "windows-sys 0.48.0",
+]
+
 [[package]]
 name = "ppv-lite86"
 version = "0.2.16"
@@ -1880,6 +2177,15 @@ dependencies = [
  "bitflags",
 ]
 
+[[package]]
+name = "redox_syscall"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
+dependencies = [
+ "bitflags",
+]
+
 [[package]]
 name = "redox_users"
 version = "0.4.3"
@@ -1887,7 +2193,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
 dependencies = [
  "getrandom",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "thiserror",
 ]
 
@@ -1953,10 +2259,24 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "db4165c9963ab29e422d6c26fbc1d37f15bace6b2810221f9d925023480fcf0e"
 dependencies = [
  "bitflags",
- "errno",
+ "errno 0.2.8",
+ "io-lifetimes",
+ "libc",
+ "linux-raw-sys 0.1.3",
+ "windows-sys 0.45.0",
+]
+
+[[package]]
+name = "rustix"
+version = "0.37.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2aae838e49b3d63e9274e1c01833cc8139d3fec468c3b84688c628f44b1ae11d"
+dependencies = [
+ "bitflags",
+ "errno 0.3.1",
  "io-lifetimes",
  "libc",
- "linux-raw-sys",
+ "linux-raw-sys 0.3.8",
  "windows-sys 0.45.0",
 ]
 
@@ -2042,6 +2362,38 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "serde_repr"
+version = "0.1.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bcec881020c684085e55a25f7fd888954d56609ef363479dc5a1305eb0d40cab"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.10",
+]
+
+[[package]]
+name = "sha1"
+version = "0.10.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f04293dc80c3993519f2d7f6f511707ee7094fe0c6d3406feb330cdb3540eba3"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest",
+]
+
+[[package]]
+name = "signal-hook"
+version = "0.3.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "732768f1176d21d09e076c23a93123d40bba92d50c4058da34d45c8de8e682b9"
+dependencies = [
+ "libc",
+ "signal-hook-registry",
+]
+
 [[package]]
 name = "signal-hook-registry"
 version = "1.4.0"
@@ -2230,6 +2582,19 @@ dependencies = [
  "version-compare",
 ]
 
+[[package]]
+name = "tempfile"
+version = "3.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b9fbec84f381d5795b08656e4912bec604d162bff9291d6189a78f4c8ab87998"
+dependencies = [
+ "cfg-if",
+ "fastrand",
+ "redox_syscall 0.3.5",
+ "rustix 0.37.7",
+ "windows-sys 0.45.0",
+]
+
 [[package]]
 name = "term"
 version = "0.7.0"
@@ -2317,6 +2682,7 @@ dependencies = [
  "signal-hook-registry",
  "socket2",
  "tokio-macros",
+ "tracing",
  "windows-sys 0.45.0",
 ]
 
@@ -2353,12 +2719,60 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "tracing"
+version = "0.1.37"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8"
+dependencies = [
+ "cfg-if",
+ "pin-project-lite",
+ "tracing-attributes",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-attributes"
+version = "0.1.24"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0f57e3ca2a01450b1a921183a9c9cbfda207fd822cef4ccb00a65402cbba7a74"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.10",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0955b8137a1df6f1a2e9a37d8a6656291ff0297c1a97c24e0d8425fe2312f79a"
+dependencies = [
+ "once_cell",
+]
+
+[[package]]
+name = "typenum"
+version = "1.16.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba"
+
 [[package]]
 name = "ucd-trie"
 version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9e79c4d996edb816c91e4308506774452e55e95c3c9de07b6729e17e15a5ef81"
 
+[[package]]
+name = "uds_windows"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ce65604324d3cce9b966701489fbd0cf318cb1f7bd9dd07ac9a4ee6fb791930d"
+dependencies = [
+ "tempfile",
+ "winapi",
+]
+
 [[package]]
 name = "unescape"
 version = "0.1.0"
@@ -2404,6 +2818,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "waker-fn"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d5b2c62b4012a3e1eca5a7e077d13b3bf498c4073e33ccd58626607748ceeca"
+
 [[package]]
 name = "walkdir"
 version = "2.3.2"
@@ -2554,6 +2974,15 @@ dependencies = [
  "windows-targets 0.42.2",
 ]
 
+[[package]]
+name = "windows-sys"
+version = "0.48.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
+dependencies = [
+ "windows-targets 0.48.0",
+]
+
 [[package]]
 name = "windows-targets"
 version = "0.42.2"
@@ -2668,6 +3097,15 @@ version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"
 
+[[package]]
+name = "winnow"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ae8970b36c66498d8ff1d66685dc86b91b29db0c7739899012f63a63814b4b28"
+dependencies = [
+ "memchr",
+]
+
 [[package]]
 name = "x11"
 version = "2.20.0"
@@ -2700,6 +3138,16 @@ dependencies = [
  "nix 0.25.0",
 ]
 
+[[package]]
+name = "xdg-home"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2769203cd13a0c6015d515be729c526d041e9cf2c0cc478d57faee85f40c6dcd"
+dependencies = [
+ "nix 0.26.2",
+ "winapi",
+]
+
 [[package]]
 name = "yaml-rust"
 version = "0.4.5"
@@ -2738,3 +3186,103 @@ dependencies = [
  "strum",
  "thiserror",
 ]
+
+[[package]]
+name = "zbus"
+version = "3.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c3d77c9966c28321f1907f0b6c5a5561189d1f7311eea6d94180c6be9daab29"
+dependencies = [
+ "async-broadcast",
+ "async-process",
+ "async-recursion",
+ "async-trait",
+ "byteorder",
+ "derivative",
+ "enumflags2",
+ "event-listener",
+ "futures-core",
+ "futures-sink",
+ "futures-util",
+ "hex",
+ "nix 0.26.2",
+ "once_cell",
+ "ordered-stream",
+ "rand",
+ "serde",
+ "serde_repr",
+ "sha1",
+ "static_assertions",
+ "tokio",
+ "tracing",
+ "uds_windows",
+ "winapi",
+ "xdg-home",
+ "zbus_macros",
+ "zbus_names",
+ "zvariant",
+]
+
+[[package]]
+name = "zbus_macros"
+version = "3.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f6e341d12edaff644e539ccbbf7f161601294c9a84ed3d7e015da33155b435af"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "regex",
+ "syn 1.0.103",
+ "winnow",
+ "zvariant_utils",
+]
+
+[[package]]
+name = "zbus_names"
+version = "2.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "82441e6033be0a741157a72951a3e4957d519698f3a824439cc131c5ba77ac2a"
+dependencies = [
+ "serde",
+ "static_assertions",
+ "zvariant",
+]
+
+[[package]]
+name = "zvariant"
+version = "3.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "622cc473f10cef1b0d73b7b34a266be30ebdcfaea40ec297dd8cbda088f9f93c"
+dependencies = [
+ "byteorder",
+ "enumflags2",
+ "libc",
+ "serde",
+ "static_assertions",
+ "zvariant_derive",
+]
+
+[[package]]
+name = "zvariant_derive"
+version = "3.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5d9c1b57352c25b778257c661f3c4744b7cefb7fc09dd46909a153cce7773da2"
+dependencies = [
+ "proc-macro-crate",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.103",
+ "zvariant_utils",
+]
+
+[[package]]
+name = "zvariant_utils"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7234f0d811589db492d16893e3f21e8e2fd282e6d01b0cddee310322062cc200"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.103",
+]
diff --git a/crates/notifier_host/Cargo.toml b/crates/notifier_host/Cargo.toml
new file mode 100644
index 00000000..c13a898e
--- /dev/null
+++ b/crates/notifier_host/Cargo.toml
@@ -0,0 +1,16 @@
+[package]
+name = "notifier_host"
+version = "0.1.0"
+authors = ["elkowar <5300871+elkowar@users.noreply.github.com>"]
+edition = "2021"
+licence = "MIT"
+description = "SystemNotifierHost implementation"
+repository = "https://github.com/elkowar/eww"
+homepage = "https://github.com/elkowar/eww"
+
+[dependencies]
+gtk = { version = "0.15", features = [ "v3_22" ] }
+log = "0.4"
+thiserror = "1.0"
+tokio = { version = "^1.18", features = ["full"] }
+zbus = { version = "3.7.0", default-features = false, features = ["tokio"] }
diff --git a/crates/notifier_host/src/dbus/dbus_menu.xml b/crates/notifier_host/src/dbus/dbus_menu.xml
new file mode 100644
index 00000000..ae5d7906
--- /dev/null
+++ b/crates/notifier_host/src/dbus/dbus_menu.xml
@@ -0,0 +1,69 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+<interface name="com.canonical.dbusmenu">
+    <!-- Properties -->
+    <property name="Version" type="u" access="read" />
+    <property name="TextDirection" type="s" access="read" />
+    <property name="Status" type="s" access="read" />
+    <property name="IconThemePath" type="as" access="read" />
+
+    <!-- Functions -->
+    <method name="GetLayout">
+        <arg type="i" name="parentId" direction="in" />
+        <arg type="i" name="recursionDepth" direction="in" />
+        <arg type="as" name="propertyNames" direction="in" />
+        <arg type="u" name="revision" direction="out" />
+        <arg type="(ia{sv}av)" name="layout" direction="out" />
+    </method>
+
+    <method name="GetGroupProperties">
+        <arg type="ai" name="ids" direction="in" />
+        <arg type="as" name="propertyNames" direction="in" />
+        <arg type="a(ia{sv})" name="properties" direction="out" />
+    </method>
+
+    <method name="GetProperty">
+        <arg type="i" name="id" direction="in" />
+        <arg type="s" name="name" direction="in" />
+        <arg type="v" name="value" direction="out" />
+    </method>
+
+    <method name="Event">
+        <arg type="i" name="id" direction="in" />
+        <arg type="s" name="eventId" direction="in" />
+        <arg type="v" name="data" direction="in" />
+        <arg type="u" name="timestamp" direction="in" />
+    </method>
+
+    <method name="EventGroup">
+        <arg type="a(isvu)" name="events" direction="in" />
+        <arg type="ai" name="idErrors" direction="out" />
+    </method>
+
+    <method name="AboutToShow">
+        <arg type="i" name="id" direction="in" />
+        <arg type="b" name="needUpdate" direction="out" />
+    </method>
+
+    <method name="AboutToShowGroup">
+        <arg type="ai" name="ids" direction="in" />
+        <arg type="ai" name="updatesNeeded" direction="out" />
+        <arg type="ai" name="idErrors" direction="out" />
+    </method>
+
+    <!-- Signals -->
+    <signal name="ItemsPropertiesUpdated">
+        <arg type="a(ia{sv})" name="updatedProps" direction="out" />
+        <arg type="a(ias)" name="removedProps" direction="out" />
+    </signal>
+    <signal name="LayoutUpdated">
+        <arg type="u" name="revision" direction="out" />
+        <arg type="i" name="parent" direction="out" />
+    </signal>
+    <signal name="ItemActivationRequested">
+        <arg type="i" name="id" direction="out" />
+        <arg type="u" name="timestamp" direction="out" />
+    </signal>
+</interface>
+</node>
\ No newline at end of file
diff --git a/crates/notifier_host/src/dbus/dbus_status_notifier_item.rs b/crates/notifier_host/src/dbus/dbus_status_notifier_item.rs
new file mode 100644
index 00000000..e20e32d6
--- /dev/null
+++ b/crates/notifier_host/src/dbus/dbus_status_notifier_item.rs
@@ -0,0 +1,111 @@
+//! # DBus interface proxy for: `org.kde.StatusNotifierItem`
+//!
+//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
+//! Source: `dbus-status-notifier-item.xml`.
+//!
+//! You may prefer to adapt it, instead of using it verbatim.
+//!
+//! More information can be found in the
+//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
+//! section of the zbus documentation.
+
+use zbus::dbus_proxy;
+
+#[dbus_proxy(interface = "org.kde.StatusNotifierItem", assume_defaults = true)]
+trait StatusNotifierItem {
+    /// Activate method
+    fn activate(&self, x: i32, y: i32) -> zbus::Result<()>;
+
+    /// ContextMenu method
+    fn context_menu(&self, x: i32, y: i32) -> zbus::Result<()>;
+
+    /// Scroll method
+    fn scroll(&self, delta: i32, orientation: &str) -> zbus::Result<()>;
+
+    /// SecondaryActivate method
+    fn secondary_activate(&self, x: i32, y: i32) -> zbus::Result<()>;
+
+    /// NewAttentionIcon signal
+    #[dbus_proxy(signal)]
+    fn new_attention_icon(&self) -> zbus::Result<()>;
+
+    /// NewIcon signal
+    #[dbus_proxy(signal)]
+    fn new_icon(&self) -> zbus::Result<()>;
+
+    /// NewOverlayIcon signal
+    #[dbus_proxy(signal)]
+    fn new_overlay_icon(&self) -> zbus::Result<()>;
+
+    /// NewStatus signal
+    #[dbus_proxy(signal)]
+    fn new_status(&self, status: &str) -> zbus::Result<()>;
+
+    /// NewTitle signal
+    #[dbus_proxy(signal)]
+    fn new_title(&self) -> zbus::Result<()>;
+
+    /// NewToolTip signal
+    #[dbus_proxy(signal)]
+    fn new_tool_tip(&self) -> zbus::Result<()>;
+
+    /// AttentionIconName property
+    #[dbus_proxy(property)]
+    fn attention_icon_name(&self) -> zbus::Result<String>;
+
+    /// AttentionIconPixmap property
+    #[dbus_proxy(property)]
+    fn attention_icon_pixmap(&self) -> zbus::Result<Vec<(i32, i32, Vec<u8>)>>;
+
+    /// AttentionMovieName property
+    #[dbus_proxy(property)]
+    fn attention_movie_name(&self) -> zbus::Result<String>;
+
+    /// Category property
+    #[dbus_proxy(property)]
+    fn category(&self) -> zbus::Result<String>;
+
+    /// IconName property
+    #[dbus_proxy(property)]
+    fn icon_name(&self) -> zbus::Result<String>;
+
+    /// IconPixmap property
+    #[dbus_proxy(property)]
+    fn icon_pixmap(&self) -> zbus::Result<Vec<(i32, i32, Vec<u8>)>>;
+
+    /// IconThemePath property
+    #[dbus_proxy(property)]
+    fn icon_theme_path(&self) -> zbus::Result<String>;
+
+    /// Id property
+    #[dbus_proxy(property)]
+    fn id(&self) -> zbus::Result<String>;
+
+    /// ItemIsMenu property
+    #[dbus_proxy(property)]
+    fn item_is_menu(&self) -> zbus::Result<bool>;
+
+    /// Menu property
+    #[dbus_proxy(property)]
+    fn menu(&self) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;
+
+    /// OverlayIconName property
+    #[dbus_proxy(property)]
+    fn overlay_icon_name(&self) -> zbus::Result<String>;
+
+    /// OverlayIconPixmap property
+    #[dbus_proxy(property)]
+    fn overlay_icon_pixmap(&self) -> zbus::Result<Vec<(i32, i32, Vec<u8>)>>;
+
+    /// Status property
+    #[dbus_proxy(property)]
+    fn status(&self) -> zbus::Result<String>;
+
+    /// Title property
+    #[dbus_proxy(property)]
+    fn title(&self) -> zbus::Result<String>;
+
+    /// ToolTip property
+    #[dbus_proxy(property)]
+    fn tool_tip(&self) -> zbus::Result<(String, Vec<(i32, i32, Vec<u8>)>)>;
+}
diff --git a/crates/notifier_host/src/dbus/dbus_status_notifier_item.xml b/crates/notifier_host/src/dbus/dbus_status_notifier_item.xml
new file mode 100644
index 00000000..c33cd846
--- /dev/null
+++ b/crates/notifier_host/src/dbus/dbus_status_notifier_item.xml
@@ -0,0 +1,49 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name='org.kde.StatusNotifierItem'>
+    <annotation name="org.gtk.GDBus.C.Name" value="Item" />
+    <method name='ContextMenu'>
+      <arg type='i' direction='in' name='x'/>
+      <arg type='i' direction='in' name='y'/>
+    </method>
+    <method name='Activate'>
+      <arg type='i' direction='in' name='x'/>
+      <arg type='i' direction='in' name='y'/>
+    </method>
+    <method name='SecondaryActivate'>
+      <arg type='i' direction='in' name='x'/>
+      <arg type='i' direction='in' name='y'/>
+    </method>
+    <method name='Scroll'>
+      <arg type='i' direction='in' name='delta'/>
+      <arg type='s' direction='in' name='orientation'/>
+    </method>
+    <signal name='NewTitle'/>
+    <signal name='NewIcon'/>
+    <signal name='NewAttentionIcon'/>
+    <signal name='NewOverlayIcon'/>
+    <signal name='NewToolTip'/>
+    <signal name='NewStatus'>
+      <arg type='s' name='status'/>
+    </signal>
+    <property name='Category' type='s' access='read'/>
+    <property name='Id' type='s' access='read'/>
+    <property name='Title' type='s' access='read'/>
+    <property name='Status' type='s' access='read'/>
+    <!-- See discussion on pull #536
+    <property name='WindowId' type='u' access='read'/>
+    -->
+    <property name='IconThemePath' type='s' access='read'/>
+    <property name='IconName' type='s' access='read'/>
+    <property name='IconPixmap' type='a(iiay)' access='read'/>
+    <property name='OverlayIconName' type='s' access='read'/>
+    <property name='OverlayIconPixmap' type='a(iiay)' access='read'/>
+    <property name='AttentionIconName' type='s' access='read'/>
+    <property name='AttentionIconPixmap' type='a(iiay)' access='read'/>
+    <property name='AttentionMovieName' type='s' access='read'/>
+    <property name='ToolTip' type='(sa(iiay)ss)' access='read'/>
+    <property name='Menu' type='o' access='read'/>
+    <property name='ItemIsMenu' type='b' access='read'/>
+  </interface>
+</node>
diff --git a/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs b/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs
new file mode 100644
index 00000000..8c352793
--- /dev/null
+++ b/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs
@@ -0,0 +1,53 @@
+//! # DBus interface proxy for: `org.kde.StatusNotifierWatcher`
+//!
+//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
+//! Source: `dbus-status-notifier-watcher.xml`.
+//!
+//! You may prefer to adapt it, instead of using it verbatim.
+//!
+//! More information can be found in the
+//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
+//! section of the zbus documentation.
+
+use zbus::dbus_proxy;
+
+#[dbus_proxy(
+    default_service="org.kde.StatusNotifierWatcher",
+    interface="org.kde.StatusNotifierWatcher",
+    default_path="/StatusNotifierWatcher",
+)]
+trait StatusNotifierWatcher {
+    /// RegisterStatusNotifierHost method
+    fn register_status_notifier_host(&self, service: &str) -> zbus::Result<()>;
+
+    /// RegisterStatusNotifierItem method
+    fn register_status_notifier_item(&self, service: &str) -> zbus::Result<()>;
+
+    /// StatusNotifierHostRegistered signal
+    #[dbus_proxy(signal)]
+    fn status_notifier_host_registered(&self) -> zbus::Result<()>;
+
+    /// StatusNotifierHostUnregistered signal
+    #[dbus_proxy(signal)]
+    fn status_notifier_host_unregistered(&self) -> zbus::Result<()>;
+
+    /// StatusNotifierItemRegistered signal
+    #[dbus_proxy(signal)]
+    fn status_notifier_item_registered(&self, service: &str) -> zbus::Result<()>;
+
+    /// StatusNotifierItemUnregistered signal
+    #[dbus_proxy(signal)]
+    fn status_notifier_item_unregistered(&self, service: &str) -> zbus::Result<()>;
+
+    /// IsStatusNotifierHostRegistered property
+    #[dbus_proxy(property)]
+    fn is_status_notifier_host_registered(&self) -> zbus::Result<bool>;
+
+    /// ProtocolVersion property
+    #[dbus_proxy(property)]
+    fn protocol_version(&self) -> zbus::Result<i32>;
+
+    /// RegisteredStatusNotifierItems property
+    #[dbus_proxy(property)]
+    fn registered_status_notifier_items(&self) -> zbus::Result<Vec<String>>;
+}
diff --git a/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.xml b/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.xml
new file mode 100644
index 00000000..6370e4dd
--- /dev/null
+++ b/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.xml
@@ -0,0 +1,52 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.kde.StatusNotifierWatcher">
+    <annotation name="org.gtk.GDBus.C.Name" value="Watcher" />
+
+    <!-- methods -->
+    <method name="RegisterStatusNotifierItem">
+      <annotation name="org.gtk.GDBus.C.Name" value="RegisterItem" />
+      <arg name="service" type="s" direction="in"/>
+    </method>
+
+    <method name="RegisterStatusNotifierHost">
+        <annotation name="org.gtk.GDBus.C.Name" value="RegisterHost" />
+        <arg name="service" type="s" direction="in"/>
+    </method>
+
+
+    <!-- properties -->
+
+    <property name="RegisteredStatusNotifierItems" type="as" access="read">
+      <annotation name="org.gtk.GDBus.C.Name" value="RegisteredItems" />
+      <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="QStringList"/>
+    </property>
+
+    <property name="IsStatusNotifierHostRegistered" type="b" access="read">
+      <annotation name="org.gtk.GDBus.C.Name" value="IsHostRegistered" />
+    </property>
+
+    <property name="ProtocolVersion" type="i" access="read"/>
+
+
+    <!-- signals -->
+
+    <signal name="StatusNotifierItemRegistered">
+      <annotation name="org.gtk.GDBus.C.Name" value="ItemRegistered" />
+      <arg type="s" direction="out" name="service" />
+    </signal>
+
+    <signal name="StatusNotifierItemUnregistered">
+      <annotation name="org.gtk.GDBus.C.Name" value="ItemUnregistered" />
+      <arg type="s" direction="out" name="service" />
+    </signal>
+
+    <signal name="StatusNotifierHostRegistered">
+      <annotation name="org.gtk.GDBus.C.Name" value="HostRegistered" />
+    </signal>
+
+    <signal name="StatusNotifierHostUnregistered">
+      <annotation name="org.gtk.GDBus.C.Name" value="HostUnregistered" />
+    </signal>
+  </interface>
+</node>
\ No newline at end of file
diff --git a/crates/notifier_host/src/dbus/mod.rs b/crates/notifier_host/src/dbus/mod.rs
new file mode 100644
index 00000000..2852ce8f
--- /dev/null
+++ b/crates/notifier_host/src/dbus/mod.rs
@@ -0,0 +1,11 @@
+//! # DBus interface proxies
+//!
+//! The interface XML files are taken from
+//! [Waybar](https://github.com/Alexays/Waybar/tree/master/protocol), and the proxies generated
+//! with [zbus-gen](https://docs.rs/crate/zbus_xmlgen/latest).
+
+mod dbus_status_notifier_item;
+pub use dbus_status_notifier_item::*;
+
+mod dbus_status_notifier_watcher;
+pub use dbus_status_notifier_watcher::*;
diff --git a/crates/notifier_host/src/error.rs b/crates/notifier_host/src/error.rs
new file mode 100644
index 00000000..a8a2d6f8
--- /dev/null
+++ b/crates/notifier_host/src/error.rs
@@ -0,0 +1,11 @@
+use thiserror::Error;
+
+#[derive(Error, Debug)]
+pub enum Error {
+    #[error("Dbus connection error")]
+    DbusError(#[from] zbus::Error),
+    #[error("Service path {0} was not understood")]
+    DbusAddressError(String),
+}
+
+pub type Result<T> = std::result::Result<T, Error>;
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
new file mode 100644
index 00000000..79c1235a
--- /dev/null
+++ b/crates/notifier_host/src/host.rs
@@ -0,0 +1,65 @@
+use crate::*;
+
+use zbus::export::ordered_stream::{self, OrderedStreamExt};
+
+pub trait Host {
+    fn add_item(&mut self, id: &str, item: Item);
+    fn remove_item(&mut self, id: &str);
+}
+
+// Attach to dbus and forward events to Host.
+//
+// This task is blocking and won't return unless an error occurs.
+pub async fn serve(host: &mut dyn Host, id: &str) -> Result<()> {
+    // From <https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierHost/>:
+    //
+    // Instances of this service are registered on the Dbus session bus, under a name on the
+    // form org.freedesktop.StatusNotifierHost-id where id is an unique identifier, that keeps
+    // the names unique on the bus, such as the process-id of the application or another type
+    // of identifier if more that one StatusNotifierHost is registered by the same process.
+
+    let wellknown_name = format!("org.freedesktop.StatusNotifierHost-{}-{}", std::process::id(), id);
+    let con = zbus::ConnectionBuilder::session()?
+        .name(wellknown_name.as_str())?
+        .build()
+        .await?;
+
+    // register ourself to StatusNotifierWatcher
+    let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;
+    snw.register_status_notifier_host(&wellknown_name).await?;
+
+    // initial items first
+    for svc in snw.registered_status_notifier_items().await? {
+        let item = Item::from_address(&con, &svc).await?;
+        host.add_item(&svc, item);
+    }
+
+    // TODO this is a race condition? we might miss items that appear at this time
+
+    enum ItemEvent {
+        NewItem(dbus::StatusNotifierItemRegistered),
+        GoneItem(dbus::StatusNotifierItemUnregistered),
+    }
+
+    let new_items = snw.receive_status_notifier_item_registered().await?;
+    let gone_items = snw.receive_status_notifier_item_unregistered().await?;
+    let mut ev_stream = ordered_stream::join(
+        OrderedStreamExt::map(new_items, ItemEvent::NewItem),
+        OrderedStreamExt::map(gone_items, ItemEvent::GoneItem),
+    );
+    while let Some(ev) = ev_stream.next().await {
+        match ev {
+            ItemEvent::NewItem(sig) => {
+                let args = sig.args()?;
+                let item = Item::from_address(&con, args.service).await?;
+                host.add_item(args.service, item);
+            },
+            ItemEvent::GoneItem(sig) => {
+                let args = sig.args()?;
+                host.remove_item(args.service);
+            },
+        }
+    }
+
+    Ok(())
+}
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
new file mode 100644
index 00000000..d201a0b2
--- /dev/null
+++ b/crates/notifier_host/src/item.rs
@@ -0,0 +1,195 @@
+use crate::*;
+
+use log;
+use gtk::{self, prelude::*};
+use zbus::export::ordered_stream::OrderedStreamExt;
+use tokio::sync::watch;
+
+#[derive(Debug, Clone, Copy)]
+pub enum Status {
+    /// The item doesn't convey important information to the user, it can be considered an "idle"
+    /// status and is likely that visualizations will chose to hide it.
+    Passive,
+    /// The item is active, is more important that the item will be shown in some way to the user.
+    Active,
+    /// The item carries really important information for the user, such as battery charge running
+    /// out and is wants to incentive the direct user intervention. Visualizations should emphasize
+    /// in some way the items with NeedsAttention status.
+    NeedsAttention,
+}
+
+impl std::str::FromStr for Status {
+    type Err = ();
+
+    fn from_str(s: &str) -> std::result::Result<Self, ()> {
+        match s {
+            "Passive" => Ok(Status::Passive),
+            "Active" => Ok(Status::Active),
+            "NeedsAttention" => Ok(Status::NeedsAttention),
+            _ => Err(()),
+        }
+    }
+}
+
+#[derive(Clone, Debug)]
+pub struct Item {
+    pub sni: dbus::StatusNotifierItemProxy<'static>,
+    status_rx: watch::Receiver<Status>,
+    title_rx: watch::Receiver<String>,
+}
+
+/// Split a sevice name e.g. `:1.50:/org/ayatana/NotificationItem/nm_applet` into the address and
+/// path.
+///
+/// Original logic from <https://github.com/oknozor/stray/blob/main/stray/src/notifier_watcher/notifier_address.rs>
+fn split_service_name(service: &str) -> Result<(String, String)> {
+    if let Some((addr, path)) = service.split_once('/') {
+        Ok((addr.to_owned(), format!("/{}", path)))
+    } else if service.contains(':') {
+        let addr = service.split(':').skip(1).next();
+        // Some StatusNotifierItems will not return an object path, in that case we fallback
+        // to the default path.
+        if let Some(addr) = addr {
+            Ok((addr.to_owned(), "/StatusNotifierItem".to_owned()))
+        } else {
+            Err(Error::DbusAddressError(service.to_owned()))
+        }
+    } else {
+        Err(Error::DbusAddressError(service.to_owned()))
+    }
+}
+
+impl Item {
+    pub async fn from_address(con: &zbus::Connection, addr: &str) -> Result<Self> {
+        let (addr, path) = split_service_name(addr)?;
+        let sni = dbus::StatusNotifierItemProxy::builder(con)
+            .destination(addr)?
+            .path(path)?
+            .build()
+            .await?;
+
+        let (status_tx, status_rx) = watch::channel(sni.status().await?.parse().unwrap());
+        tokio::spawn({
+            let sni = sni.clone();
+            async move {
+                let mut new_status_stream = sni.receive_new_status().await.unwrap();
+                while let Some(sig) = new_status_stream.next().await {
+                    let args = sig.args().unwrap();
+                    let status: Status = args.status.parse().unwrap();
+                    status_tx.send_replace(status);
+                }
+            }
+        });
+
+        let (title_tx, title_rx) = watch::channel(sni.title().await?);
+        tokio::spawn({
+            let sni = sni.clone();
+            async move {
+                let mut new_title_stream = sni.receive_new_title().await.unwrap();
+                while let Some(_) = new_title_stream.next().await {
+                    let title = sni.title().await.unwrap();
+                    title_tx.send_replace(title);
+                }
+            }
+        });
+
+        Ok(Item {
+            sni,
+            status_rx,
+            title_rx,
+        })
+    }
+
+    pub fn status(&self) -> watch::Receiver<Status> {
+        self.status_rx.clone()
+    }
+
+    pub fn title(&self) -> watch::Receiver<String> {
+        self.title_rx.clone()
+    }
+}
+
+#[derive(thiserror::Error, Debug)]
+pub enum IconError {
+    #[error("Dbus error")]
+    DbusError(#[from] zbus::Error),
+    #[error("Failed to load icon {icon_name:?} from theme {theme_path:?}")]
+    LoadIconFromTheme {
+        icon_name: String,
+        theme_path: String,
+        source: gtk::glib::Error,
+    },
+    #[error("Failed to load icon {icon_name:?} from default theme")]
+    LoadIconFromDefaultTheme {
+        icon_name: String,
+        source: gtk::glib::Error,
+    },
+}
+
+impl Item {
+    pub fn load_pixmap(width: i32, height: i32, mut data: Vec<u8>) -> gtk::Image {
+        // We need to convert data from ARGB32 to RGBA32
+        for chunk in data.chunks_mut(4) {
+            let a = chunk[0];
+            let r = chunk[1];
+            let g = chunk[2];
+            let b = chunk[3];
+            chunk[0] = r;
+            chunk[1] = g;
+            chunk[2] = b;
+            chunk[3] = a;
+        }
+
+        let pixmap = gtk::gdk_pixbuf::Pixbuf::from_bytes(
+            &gtk::glib::Bytes::from_owned(data),
+            gtk::gdk_pixbuf::Colorspace::Rgb,
+            true,
+            8,
+            width,
+            height,
+            width * 4,
+        );
+        gtk::Image::from_pixbuf(Some(&pixmap))
+    }
+
+    pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+        let icon_name = self.sni.icon_name().await?;
+        let icon_theme_path = self.sni.icon_theme_path().await?;
+
+        if icon_theme_path != "" {
+            // icon supplied a theme path, so only look there
+            let theme = gtk::IconTheme::new();
+            theme.prepend_search_path(&icon_theme_path);
+
+            return match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
+                Err(e) => Err(IconError::LoadIconFromTheme {
+                    icon_name,
+                    theme_path: icon_theme_path,
+                    source: e,
+                }),
+                Ok(pb) => return Ok(pb.unwrap()),
+            }
+        }
+
+        // fallback to default theme
+        let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
+        match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
+            // TODO specifically match on icon missing here
+            Err(e) => log::warn!("Could not find icon {:?} in default theme: {}", &icon_name, e),
+            Ok(pb) => return Ok(pb.unwrap()),
+        }
+
+        // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are available."
+        // TODO icon_pixmap
+
+        // fallback to default icon
+        let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
+        return match theme.load_icon("image-missing", size, gtk::IconLookupFlags::FORCE_SIZE) {
+            Err(e) => Err(IconError::LoadIconFromDefaultTheme {
+                icon_name: "image-missing".to_owned(),
+                source: e,
+            }),
+            Ok(pb) => return Ok(pb.unwrap()),
+        }
+    }
+}
diff --git a/crates/notifier_host/src/lib.rs b/crates/notifier_host/src/lib.rs
new file mode 100644
index 00000000..98adcfbd
--- /dev/null
+++ b/crates/notifier_host/src/lib.rs
@@ -0,0 +1,10 @@
+pub mod dbus;
+
+mod error;
+pub use error::*;
+
+mod host;
+pub use host::*;
+
+mod item;
+pub use item::*;

From bec80f91bc08e1fa37206ebab42f84be6d423cfb Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Mon, 20 Mar 2023 17:20:51 +1100
Subject: [PATCH 03/30] Implement systray widget

---
 Cargo.lock                                   |  1 +
 crates/eww/Cargo.toml                        |  1 +
 crates/eww/src/widgets/mod.rs                |  1 +
 crates/eww/src/widgets/systray.rs            | 76 ++++++++++++++++++++
 crates/eww/src/widgets/widget_definitions.rs | 29 +++++++-
 5 files changed, 107 insertions(+), 1 deletion(-)
 create mode 100644 crates/eww/src/widgets/systray.rs

diff --git a/Cargo.lock b/Cargo.lock
index 4e6ebdc4..c4870984 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -820,6 +820,7 @@ dependencies = [
  "log",
  "maplit",
  "nix 0.26.2",
+ "notifier_host",
  "notify",
  "once_cell",
  "pretty_env_logger",
diff --git a/crates/eww/Cargo.toml b/crates/eww/Cargo.toml
index 35e2ce6a..2286f703 100644
--- a/crates/eww/Cargo.toml
+++ b/crates/eww/Cargo.toml
@@ -65,3 +65,4 @@ codespan-reporting = "0.11"
 simplexpr = { version = "0.1.0", path = "../simplexpr" }
 eww_shared_util = { version = "0.1.0", path = "../eww_shared_util" }
 yuck = { version = "0.1.0", path = "../yuck", default-features = false}
+notifier_host = { version = "0.1.0", path = "../notifier_host" }
diff --git a/crates/eww/src/widgets/mod.rs b/crates/eww/src/widgets/mod.rs
index e5e25b7c..33ad4181 100644
--- a/crates/eww/src/widgets/mod.rs
+++ b/crates/eww/src/widgets/mod.rs
@@ -4,6 +4,7 @@ pub mod build_widget;
 pub mod circular_progressbar;
 pub mod def_widget_macro;
 pub mod graph;
+mod systray;
 pub mod transform;
 pub mod widget_definitions;
 
diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
new file mode 100644
index 00000000..fc5cdf44
--- /dev/null
+++ b/crates/eww/src/widgets/systray.rs
@@ -0,0 +1,76 @@
+#![allow(unused)]
+
+use gtk::prelude::*;
+use notifier_host;
+
+async fn gtk_run<F, R1, R>(f: F) -> R
+where
+    F: FnOnce() -> R1 + 'static,
+    R1: std::future::Future<Output=R>,
+    R: 'static,
+{
+    let (tx, rx) = tokio::sync::oneshot::channel();
+    glib::MainContext::default().spawn_local(async move {
+        let r = f().await;
+        tx.send(r).map_err(|_| ()).unwrap();
+    });
+    rx.await.unwrap()
+}
+
+struct Host {
+    menubar: gtk::MenuBar,
+    items: std::collections::HashMap<String, gtk::MenuItem>,
+}
+
+async fn watch_foreach<T: std::fmt::Debug>(mut rx: tokio::sync::watch::Receiver<T>, mut f: impl FnMut(&T)) {
+    f(&rx.borrow());
+    while rx.changed().await.is_ok() {
+        f(&rx.borrow());
+    }
+}
+
+impl notifier_host::Host for Host {
+    fn add_item(&mut self, id: &str, item: notifier_host::Item) {
+        let mi = gtk::MenuItem::new();
+        self.menubar.add(&mi);
+        if let Some(old_mi) = self.items.insert(id.to_string(), mi.clone()) {
+            self.menubar.remove(&old_mi);
+        }
+
+        // maintain title
+        glib::MainContext::default().spawn_local({
+            let mi = mi.clone();
+            watch_foreach(item.title(), move |title| {
+                mi.set_tooltip_text(Some(title));
+            })
+        });
+
+        let icon = gtk::Image::new();
+        mi.add(&icon);
+
+        glib::MainContext::default().spawn_local(async move {
+            let img = item.icon(24).await.unwrap();
+            icon.set_from_pixbuf(Some(&img));
+        });
+
+        mi.show_all();
+    }
+    fn remove_item(&mut self, id: &str) {
+        if let Some(mi) = self.items.get(id) {
+            self.menubar.remove(mi);
+        } else {
+            log::warn!("Tried to remove nonexistent item {:?} from systray", id);
+        }
+    }
+}
+
+pub fn maintain_menubar(menubar: gtk::MenuBar) {
+    menubar.show_all();
+    glib::MainContext::default().spawn_local(async move {
+        let mut host = Host {
+            menubar,
+            items: std::collections::HashMap::new(),
+        };
+        notifier_host::serve(&mut host, "eww").await.unwrap();
+    });
+}
diff --git a/crates/eww/src/widgets/widget_definitions.rs b/crates/eww/src/widgets/widget_definitions.rs
index 2cdc9071..4395d20e 100644
--- a/crates/eww/src/widgets/widget_definitions.rs
+++ b/crates/eww/src/widgets/widget_definitions.rs
@@ -3,7 +3,7 @@ use super::{build_widget::BuilderArgs, circular_progressbar::*, run_command, tra
 use crate::{
     def_widget, enum_parse, error_handling_ctx,
     util::{list_difference, unindent},
-    widgets::build_widget::build_gtk_widget,
+    widgets::{build_widget::build_gtk_widget, systray},
 };
 use anyhow::{anyhow, Context, Result};
 use codespan_reporting::diagnostic::Severity;
@@ -80,6 +80,7 @@ pub const BUILTIN_WIDGET_NAMES: &[&str] = &[
     WIDGET_NAME_REVEALER,
     WIDGET_NAME_SCROLL,
     WIDGET_NAME_OVERLAY,
+    WIDGET_NAME_SYSTRAY,
 ];
 
 //// widget definitions
@@ -107,6 +108,7 @@ pub(super) fn widget_use_to_gtk_widget(bargs: &mut BuilderArgs) -> Result<gtk::W
         WIDGET_NAME_REVEALER => build_gtk_revealer(bargs)?.upcast(),
         WIDGET_NAME_SCROLL => build_gtk_scrolledwindow(bargs)?.upcast(),
         WIDGET_NAME_OVERLAY => build_gtk_overlay(bargs)?.upcast(),
+        WIDGET_NAME_SYSTRAY => build_systray(bargs)?.upcast(),
         _ => {
             return Err(DiagError(gen_diagnostic! {
                 msg = format!("referenced unknown widget `{}`", bargs.widget_use.name),
@@ -1035,6 +1037,21 @@ fn build_graph(bargs: &mut BuilderArgs) -> Result<super::graph::Graph> {
     Ok(w)
 }
 
+const WIDGET_NAME_SYSTRAY: &str = "systray";
+/// @widget systray
+/// @desc Tray for system notifier icons
+fn build_systray(bargs: &mut BuilderArgs) -> Result<gtk::MenuBar> {
+    let w = gtk::MenuBar::new();
+
+    def_widget!(bargs, _g, w, {
+        // @prop pack-direction - how to arrange tray items
+        prop(pack_direction: as_string) { w.set_pack_direction(parse_packdirection(&pack_direction)?); },
+    });
+
+    systray::maintain_menubar(w.clone());
+    Ok(w)
+}
+
 /// @var orientation - "vertical", "v", "horizontal", "h"
 fn parse_orientation(o: &str) -> Result<gtk::Orientation> {
     enum_parse! { "orientation", o,
@@ -1089,6 +1106,16 @@ fn parse_justification(j: &str) -> Result<gtk::Justification> {
     }
 }
 
+/// @var packdirection - "right", "ltr", "left", "rtl", "down", "ttb", "up", "btt"
+fn parse_packdirection(o: &str) -> Result<gtk::PackDirection> {
+    enum_parse! { "packdirection", o,
+        "right" | "ltr" => gtk::PackDirection::Ltr,
+        "left" | "rtl" => gtk::PackDirection::Rtl,
+        "down" | "ttb" => gtk::PackDirection::Ttb,
+        "up" | "btt" => gtk::PackDirection::Btt,
+    }
+}
+
 /// Connect a function to the first map event of a widget. After that first map, the handler will get disconnected.
 fn connect_first_map<W: IsA<gtk::Widget>, F: Fn(&W) + 'static>(widget: &W, func: F) {
     let signal_handler_id = std::rc::Rc::new(std::cell::RefCell::new(None));

From a8bdcf7c0661d9cb3b8805e083f291717a3e0a5c Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Wed, 5 Apr 2023 17:29:05 +1000
Subject: [PATCH 04/30] Use dbusmenu-gtk3

---
 Cargo.lock                        | 54 +++++++++++++++++++++++++++++++
 crates/eww/src/widgets/systray.rs | 14 +++++---
 crates/notifier_host/Cargo.toml   |  1 +
 crates/notifier_host/src/item.rs  |  6 ++++
 4 files changed, 71 insertions(+), 4 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index c4870984..4e9bf961 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -632,6 +632,59 @@ dependencies = [
  "syn 1.0.103",
 ]
 
+[[package]]
+name = "dbusmenu-glib"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fd1629dccc5775e0668eb9f07e78d1b88392a63efc34033a18c87ea44318b894"
+dependencies = [
+ "dbusmenu-glib-sys",
+ "glib",
+ "libc",
+]
+
+[[package]]
+name = "dbusmenu-glib-sys"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ff9ed40330718c94342b953c997ac19d840db07a7710fe35b45a5d3a3a1d6eb"
+dependencies = [
+ "glib-sys",
+ "gobject-sys",
+ "libc",
+ "system-deps",
+]
+
+[[package]]
+name = "dbusmenu-gtk3"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b15e02bf53eed790cee4d6111643529bf2fdb82c9e61242407d254612f98436e"
+dependencies = [
+ "atk",
+ "dbusmenu-glib",
+ "dbusmenu-gtk3-sys",
+ "glib",
+ "gtk",
+ "libc",
+]
+
+[[package]]
+name = "dbusmenu-gtk3-sys"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6f30ba5f8aec0e38a84c579bc8ee3db6f6417b201e729fdd96a23d1f61cb6eca"
+dependencies = [
+ "dbusmenu-glib-sys",
+ "gdk-pixbuf-sys",
+ "gdk-sys",
+ "glib-sys",
+ "gobject-sys",
+ "gtk-sys",
+ "libc",
+ "system-deps",
+]
+
 [[package]]
 name = "derivative"
 version = "2.2.0"
@@ -1727,6 +1780,7 @@ dependencies = [
 name = "notifier_host"
 version = "0.1.0"
 dependencies = [
+ "dbusmenu-gtk3",
  "gtk",
  "log",
  "thiserror",
diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index fc5cdf44..2844fdff 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -48,11 +48,17 @@ impl notifier_host::Host for Host {
         let icon = gtk::Image::new();
         mi.add(&icon);
 
-        glib::MainContext::default().spawn_local(async move {
-            let img = item.icon(24).await.unwrap();
-            icon.set_from_pixbuf(Some(&img));
-        });
+        // other initialisation
+        glib::MainContext::default().spawn_local({
+            let mi = mi.clone();
+            async move {
+                let img = item.icon(24).await.unwrap();
+                icon.set_from_pixbuf(Some(&img));
 
+                let menu = item.menu().await.unwrap();
+                mi.set_submenu(Some(&menu));
+            }
+        });
         mi.show_all();
     }
     fn remove_item(&mut self, id: &str) {
diff --git a/crates/notifier_host/Cargo.toml b/crates/notifier_host/Cargo.toml
index c13a898e..3cfa4741 100644
--- a/crates/notifier_host/Cargo.toml
+++ b/crates/notifier_host/Cargo.toml
@@ -14,3 +14,4 @@ log = "0.4"
 thiserror = "1.0"
 tokio = { version = "^1.18", features = ["full"] }
 zbus = { version = "3.7.0", default-features = false, features = ["tokio"] }
+dbusmenu-gtk3 = "0.1.0"
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index d201a0b2..21df0054 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -192,4 +192,10 @@ impl Item {
             Ok(pb) => return Ok(pb.unwrap()),
         }
     }
+
+    pub async fn menu(&self) -> Result<gtk::Menu> {
+        // TODO better handling if menu() method doesn't exist
+        let menu = dbusmenu_gtk3::Menu::new(self.sni.destination(), &self.sni.menu().await?);
+        Ok(menu.upcast())
+    }
 }

From dace391a140c57262b7cb5ff9672227c7c373c6f Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Wed, 5 Apr 2023 17:29:36 +1000
Subject: [PATCH 05/30] Update flake.nix

---
 flake.nix | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/flake.nix b/flake.nix
index d0973838..456564e9 100644
--- a/flake.nix
+++ b/flake.nix
@@ -61,6 +61,10 @@
               rust
               rust-analyzer-unwrapped
               gcc
+              glib
+              gdk-pixbuf
+              librsvg
+              libdbusmenu-gtk3
               gtk3
               gtk-layer-shell
               pkg-config

From 976123b7b75e5b82297003cd83f3653d91316cca Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Wed, 5 Apr 2023 17:43:58 +1000
Subject: [PATCH 06/30] US spelling of license

---
 crates/notifier_host/Cargo.toml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/crates/notifier_host/Cargo.toml b/crates/notifier_host/Cargo.toml
index 3cfa4741..c69b3871 100644
--- a/crates/notifier_host/Cargo.toml
+++ b/crates/notifier_host/Cargo.toml
@@ -3,7 +3,7 @@ name = "notifier_host"
 version = "0.1.0"
 authors = ["elkowar <5300871+elkowar@users.noreply.github.com>"]
 edition = "2021"
-licence = "MIT"
+license = "MIT"
 description = "SystemNotifierHost implementation"
 repository = "https://github.com/elkowar/eww"
 homepage = "https://github.com/elkowar/eww"

From 8573b48f218a1bd1bb04140d9d4c4aeebab9a18f Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sat, 8 Apr 2023 23:42:07 +1000
Subject: [PATCH 07/30] Fix possible TOCTOU

---
 crates/notifier_host/src/host.rs | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index 79c1235a..aed2ea33 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -28,21 +28,21 @@ pub async fn serve(host: &mut dyn Host, id: &str) -> Result<()> {
     let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;
     snw.register_status_notifier_host(&wellknown_name).await?;
 
-    // initial items first
-    for svc in snw.registered_status_notifier_items().await? {
-        let item = Item::from_address(&con, &svc).await?;
-        host.add_item(&svc, item);
-    }
-
-    // TODO this is a race condition? we might miss items that appear at this time
-
     enum ItemEvent {
         NewItem(dbus::StatusNotifierItemRegistered),
         GoneItem(dbus::StatusNotifierItemUnregistered),
     }
 
+    // start listening to these streams
     let new_items = snw.receive_status_notifier_item_registered().await?;
     let gone_items = snw.receive_status_notifier_item_unregistered().await?;
+
+    // initial items first
+    for svc in snw.registered_status_notifier_items().await? {
+        let item = Item::from_address(&con, &svc).await?;
+        host.add_item(&svc, item);
+    }
+
     let mut ev_stream = ordered_stream::join(
         OrderedStreamExt::map(new_items, ItemEvent::NewItem),
         OrderedStreamExt::map(gone_items, ItemEvent::GoneItem),

From b232b394ac8590d18d8e5ca7dffa2c3b06a28c9e Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sat, 8 Apr 2023 23:43:29 +1000
Subject: [PATCH 08/30] Change how hosts are started

---
 Cargo.lock                        |  1 +
 crates/eww/Cargo.toml             |  1 +
 crates/eww/src/widgets/systray.rs |  4 +++-
 crates/notifier_host/src/host.rs  | 30 +++++++++++++++++++++---------
 4 files changed, 26 insertions(+), 10 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 4e9bf961..37169b60 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -889,6 +889,7 @@ dependencies = [
  "wait-timeout",
  "x11rb",
  "yuck",
+ "zbus",
 ]
 
 [[package]]
diff --git a/crates/eww/Cargo.toml b/crates/eww/Cargo.toml
index 2286f703..138034d8 100644
--- a/crates/eww/Cargo.toml
+++ b/crates/eww/Cargo.toml
@@ -47,6 +47,7 @@ once_cell = "1.14"
 nix = "0.26.2"
 simple-signal = "1.1"
 unescape = "0.1"
+zbus = { version = "3.7.0", default-features = false, features = ["tokio"] }
 
 tokio = { version = "1.26.0", features = ["full"] }
 futures-core = "0.3.27"
diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 2844fdff..417a0f77 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -73,10 +73,12 @@ impl notifier_host::Host for Host {
 pub fn maintain_menubar(menubar: gtk::MenuBar) {
     menubar.show_all();
     glib::MainContext::default().spawn_local(async move {
+        let con = zbus::Connection::session().await.unwrap();
+
         let mut host = Host {
             menubar,
             items: std::collections::HashMap::new(),
         };
-        notifier_host::serve(&mut host, "eww").await.unwrap();
+        notifier_host::host_on(&mut host, &con).await.unwrap();
     });
 }
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index aed2ea33..962ac4de 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -7,10 +7,10 @@ pub trait Host {
     fn remove_item(&mut self, id: &str);
 }
 
-// Attach to dbus and forward events to Host.
-//
-// This task is blocking and won't return unless an error occurs.
-pub async fn serve(host: &mut dyn Host, id: &str) -> Result<()> {
+/// Attach to dbus and forward events to Host.
+///
+/// This async function won't complete unless an error occurs.
+pub async fn host_on(host: &mut dyn Host, con: &zbus::Connection) -> Result<()> {
     // From <https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierHost/>:
     //
     // Instances of this service are registered on the Dbus session bus, under a name on the
@@ -18,11 +18,23 @@ pub async fn serve(host: &mut dyn Host, id: &str) -> Result<()> {
     // the names unique on the bus, such as the process-id of the application or another type
     // of identifier if more that one StatusNotifierHost is registered by the same process.
 
-    let wellknown_name = format!("org.freedesktop.StatusNotifierHost-{}-{}", std::process::id(), id);
-    let con = zbus::ConnectionBuilder::session()?
-        .name(wellknown_name.as_str())?
-        .build()
-        .await?;
+    // pick a new wellknown_name
+    let pid = std::process::id();
+    let mut i = 0;
+    let wellknown_name = loop {
+        let wellknown_name = format!("org.freedesktop.StatusNotifierHost-{}-{}", pid, i);
+        let flags = [zbus::fdo::RequestNameFlags::DoNotQueue];
+
+        use zbus::fdo::RequestNameReply::*;
+        match con.request_name_with_flags(wellknown_name.as_str(), flags.into_iter().collect()).await? {
+            PrimaryOwner => break wellknown_name,
+            Exists => {},
+            AlreadyOwner => {}, // we choose to not use an existing owner, is this correct?
+            InQueue => panic!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
+        };
+
+        i += 1;
+    };
 
     // register ourself to StatusNotifierWatcher
     let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;

From 5147bf2a296411e0beb07aeabf60c70516ab5aee Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sat, 8 Apr 2023 23:43:45 +1000
Subject: [PATCH 09/30] Add watcher

---
 crates/eww/src/widgets/systray.rs   |   2 +
 crates/notifier_host/src/lib.rs     |   3 +
 crates/notifier_host/src/watcher.rs | 233 ++++++++++++++++++++++++++++
 3 files changed, 238 insertions(+)
 create mode 100644 crates/notifier_host/src/watcher.rs

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 417a0f77..70a6d84b 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -75,6 +75,8 @@ pub fn maintain_menubar(menubar: gtk::MenuBar) {
     glib::MainContext::default().spawn_local(async move {
         let con = zbus::Connection::session().await.unwrap();
 
+        notifier_host::Watcher::new().run_on(&con).await.unwrap();
+
         let mut host = Host {
             menubar,
             items: std::collections::HashMap::new(),
diff --git a/crates/notifier_host/src/lib.rs b/crates/notifier_host/src/lib.rs
index 98adcfbd..d88a6afd 100644
--- a/crates/notifier_host/src/lib.rs
+++ b/crates/notifier_host/src/lib.rs
@@ -8,3 +8,6 @@ pub use host::*;
 
 mod item;
 pub use item::*;
+
+mod watcher;
+pub use watcher::*;
diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
new file mode 100644
index 00000000..db40099f
--- /dev/null
+++ b/crates/notifier_host/src/watcher.rs
@@ -0,0 +1,233 @@
+use zbus::dbus_interface;
+use zbus::Interface;
+use zbus::export::ordered_stream::OrderedStreamExt;
+
+pub const WATCHER_BUS_NAME: &'static str = "org.kde.StatusNotifierWatcher";
+pub const WATCHER_OBJECT_NAME: &'static str = "/StatusNotifierWatcher";
+
+fn parse_service(service: &str) -> (Option<zbus::names::BusName<'_>>, &str) {
+    if service.starts_with("/") {
+        // they sent us just the object path :(
+        (None, service)
+    } else {
+        // should be a bus name
+        (service.try_into().ok(), "/StatusNotifierItem")
+    }
+}
+
+/// Wait for a DBus service to exit
+async fn wait_for_service_exit(
+    connection: zbus::Connection,
+    service: zbus::names::BusName<'_>,
+) -> zbus::fdo::Result<()> {
+    let dbus = zbus::fdo::DBusProxy::new(&connection).await?;
+    let mut owner_changes = dbus
+        .receive_name_owner_changed_with_args(&[(0, &service)])
+        .await?;
+
+    if !dbus.name_has_owner(service.as_ref()).await? {
+        return Ok(())
+    }
+
+    while let Some(sig) = owner_changes.next().await {
+        let args = sig.args()?;
+        if args.new_owner().is_none() {
+            break
+        }
+    }
+
+    Ok(())
+}
+
+#[derive(Debug, Default)]
+pub struct Watcher {
+    tasks: tokio::task::JoinSet<()>,
+    hosts: std::sync::Arc<std::sync::Mutex<std::collections::HashSet<String>>>,
+    items: std::sync::Arc<std::sync::Mutex<std::collections::HashSet<String>>>,
+}
+
+#[dbus_interface(name="org.kde.StatusNotifierWatcher")]
+impl Watcher {
+    /// RegisterStatusNotifierHost method
+    async fn register_status_notifier_host(
+        &mut self,
+        service: &str,
+        #[zbus(header)] hdr: zbus::MessageHeader<'_>,
+        #[zbus(connection)] con: &zbus::Connection,
+        #[zbus(signal_context)] ctxt: zbus::SignalContext<'_>,
+    ) -> zbus::fdo::Result<()> {
+        let (service, _) = parse_service(service);
+        let service = if let Some(x) = service {
+            x.to_owned()
+        } else if let Some(sender) = hdr.sender()? {
+            sender.to_owned().into()
+        } else {
+            log::warn!("register_status_notifier_host: unknown sender");
+            return Err(zbus::fdo::Error::InvalidArgs("Unknown bus address".into()));
+        };
+        log::info!("new host: {}", service);
+
+        {
+            let mut hosts = self.hosts.lock().unwrap();
+            if !hosts.insert(service.to_string()) {
+                // we're already tracking them
+                return Ok(())
+            }
+        }
+
+        self.is_status_notifier_host_registered_changed(&ctxt).await?;
+        Watcher::status_notifier_host_registered(&ctxt).await?;
+
+        self.tasks.spawn({
+            let hosts = self.hosts.clone();
+            let ctxt = ctxt.to_owned();
+            let con = con.to_owned();
+            async move {
+                wait_for_service_exit(con.clone(), service.as_ref()).await.unwrap();
+                log::info!("lost host: {}", service);
+
+                {
+                    let mut hosts = hosts.lock().unwrap();
+                    hosts.remove(service.as_str());
+                }
+
+                Watcher::is_status_notifier_host_registered_refresh(&ctxt).await.unwrap();
+                Watcher::status_notifier_host_unregistered(&ctxt).await.unwrap();
+            }
+        });
+
+        Ok(())
+    }
+
+    /// StatusNotifierHostRegistered signal
+    #[dbus_interface(signal)]
+    async fn status_notifier_host_registered(ctxt: &zbus::SignalContext<'_>) -> zbus::Result<()>;
+
+    /// StatusNotifierHostUnregistered signal
+    #[dbus_interface(signal)]
+    async fn status_notifier_host_unregistered(ctxt: &zbus::SignalContext<'_>) -> zbus::Result<()>;
+
+    /// IsStatusNotifierHostRegistered property
+    #[dbus_interface(property)]
+    async fn is_status_notifier_host_registered(&self) -> bool {
+        let hosts = self.hosts.lock().unwrap();
+        !hosts.is_empty()
+    }
+
+    // ------------------------------------------------------------------------
+
+    /// RegisterStatusNotifierItem method
+    async fn register_status_notifier_item(
+        &mut self,
+        service: &str,
+        #[zbus(header)] hdr: zbus::MessageHeader<'_>,
+        #[zbus(connection)] con: &zbus::Connection,
+        #[zbus(signal_context)] ctxt: zbus::SignalContext<'_>,
+    ) -> zbus::fdo::Result<()> {
+        let (service, objpath) = parse_service(service);
+        let service = if let Some(x) = service {
+            x.to_owned()
+        } else if let Some(sender) = hdr.sender()? {
+            sender.to_owned().into()
+        } else {
+            log::warn!("register_status_notifier_item: unknown sender");
+            return Err(zbus::fdo::Error::InvalidArgs("Unknown bus address".into()));
+        };
+
+        let item = format!("{}{}", service, objpath);
+        log::info!("new item: {}", item);
+
+        {
+            let mut items = self.items.lock().unwrap();
+            if !items.insert(item.clone()) {
+                // we're already tracking them
+                return Ok(())
+            }
+        }
+
+        self.registered_status_notifier_items_changed(&ctxt).await?;
+        Watcher::status_notifier_item_registered(&ctxt, service.as_ref()).await?;
+
+        self.tasks.spawn({
+            let items = self.items.clone();
+            let ctxt = ctxt.to_owned();
+            let con = con.to_owned();
+            async move {
+                wait_for_service_exit(con.clone(), service.as_ref()).await.unwrap();
+                println!("gone item: {}", &item);
+
+                {
+                    let mut items = items.lock().unwrap();
+                    items.remove(&item);
+                }
+
+                Watcher::registered_status_notifier_items_refresh(&ctxt).await.unwrap();
+                Watcher::status_notifier_item_unregistered(&ctxt, service.as_ref()).await.unwrap();
+            }
+        });
+
+        Ok(())
+    }
+
+    /// StatusNotifierItemRegistered signal
+    #[dbus_interface(signal)]
+    async fn status_notifier_item_registered(ctxt: &zbus::SignalContext<'_>, service: zbus::names::BusName<'_>) -> zbus::Result<()>;
+
+    /// StatusNotifierItemUnregistered signal
+    #[dbus_interface(signal)]
+    async fn status_notifier_item_unregistered(ctxt: &zbus::SignalContext<'_>, service: zbus::names::BusName<'_>) -> zbus::Result<()>;
+
+    /// RegisteredStatusNotifierItems property
+    #[dbus_interface(property)]
+    async fn registered_status_notifier_items(&self) -> Vec<String> {
+        let items = self.items.lock().unwrap();
+        items.iter().cloned().collect()
+    }
+
+    // ------------------------------------------------------------------------
+
+    /// ProtocolVersion property
+    #[dbus_interface(property)]
+    fn protocol_version(&self) -> i32 {
+        0
+    }
+}
+
+impl Watcher {
+    /// Create a new Watcher.
+    pub fn new() -> Watcher {
+        Default::default()
+    }
+
+    /// Attach the Watcher to a connection.
+    pub async fn run_on(self, con: &zbus::Connection) -> zbus::Result<()> {
+        if !con.object_server().at(WATCHER_OBJECT_NAME, self).await? {
+            return Err(zbus::Error::Failure("Interface already exists at this path".into()))
+        }
+
+        // no ReplaceExisting, no AllowReplacement, no DoNotQueue
+        con.request_name_with_flags(WATCHER_BUS_NAME, Default::default()).await?;
+
+        Ok(())
+    }
+
+    // Based on is_status_notifier_host_registered_invalidate, but without requiring self
+    async fn is_status_notifier_host_registered_refresh(ctxt: &zbus::SignalContext<'_>) -> zbus::Result<()> {
+        zbus::fdo::Properties::properties_changed(
+            ctxt,
+            Self::name(),
+            &std::collections::HashMap::new(),
+            &["IsStatusNotifierHostRegistered"],
+        ).await
+    }
+
+    // Based on registered_status_notifier_items_invalidate, but without requiring self
+    async fn registered_status_notifier_items_refresh(ctxt: &zbus::SignalContext<'_>) -> zbus::Result<()> {
+        zbus::fdo::Properties::properties_changed(
+            ctxt,
+            Self::name(),
+            &std::collections::HashMap::new(),
+            &["RegisteredStatusNotifierItems"],
+        ).await
+    }
+}

From 5569eb226455e5aba01f25ce7e6ecf29cc55086d Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sun, 9 Apr 2023 19:37:10 +1000
Subject: [PATCH 10/30] Bunch of refactor

---
 crates/eww/src/widgets/systray.rs            | 22 +++++---------------
 crates/eww/src/widgets/widget_definitions.rs | 10 ++++-----
 crates/notifier_host/src/error.rs            | 11 ----------
 crates/notifier_host/src/host.rs             | 14 +++++++------
 crates/notifier_host/src/item.rs             | 15 ++++++++-----
 crates/notifier_host/src/lib.rs              |  3 ---
 crates/notifier_host/src/watcher.rs          | 21 +++++++++++++++++++
 7 files changed, 49 insertions(+), 47 deletions(-)
 delete mode 100644 crates/notifier_host/src/error.rs

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 70a6d84b..3c3521eb 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -3,20 +3,6 @@
 use gtk::prelude::*;
 use notifier_host;
 
-async fn gtk_run<F, R1, R>(f: F) -> R
-where
-    F: FnOnce() -> R1 + 'static,
-    R1: std::future::Future<Output=R>,
-    R: 'static,
-{
-    let (tx, rx) = tokio::sync::oneshot::channel();
-    glib::MainContext::default().spawn_local(async move {
-        let r = f().await;
-        tx.send(r).map_err(|_| ()).unwrap();
-    });
-    rx.await.unwrap()
-}
-
 struct Host {
     menubar: gtk::MenuBar,
     items: std::collections::HashMap<String, gtk::MenuItem>,
@@ -71,16 +57,18 @@ impl notifier_host::Host for Host {
 }
 
 pub fn maintain_menubar(menubar: gtk::MenuBar) {
+    // TODO avoid having too many zbus::Connection instances
+
     menubar.show_all();
     glib::MainContext::default().spawn_local(async move {
         let con = zbus::Connection::session().await.unwrap();
+        notifier_host::watcher_on(&con).await.unwrap();
 
-        notifier_host::Watcher::new().run_on(&con).await.unwrap();
-
+        let snw = notifier_host::register_host(&con).await.unwrap();
         let mut host = Host {
             menubar,
             items: std::collections::HashMap::new(),
         };
-        notifier_host::host_on(&mut host, &con).await.unwrap();
+        notifier_host::serve_host_forever_on(&mut host, snw).await.unwrap();
     });
 }
diff --git a/crates/eww/src/widgets/widget_definitions.rs b/crates/eww/src/widgets/widget_definitions.rs
index 4395d20e..795ac42b 100644
--- a/crates/eww/src/widgets/widget_definitions.rs
+++ b/crates/eww/src/widgets/widget_definitions.rs
@@ -1041,15 +1041,15 @@ const WIDGET_NAME_SYSTRAY: &str = "systray";
 /// @widget systray
 /// @desc Tray for system notifier icons
 fn build_systray(bargs: &mut BuilderArgs) -> Result<gtk::MenuBar> {
-    let w = gtk::MenuBar::new();
+    let gtk_widget = gtk::MenuBar::new();
 
-    def_widget!(bargs, _g, w, {
+    def_widget!(bargs, _g, gtk_widget, {
         // @prop pack-direction - how to arrange tray items
-        prop(pack_direction: as_string) { w.set_pack_direction(parse_packdirection(&pack_direction)?); },
+        prop(pack_direction: as_string) { gtk_widget.set_pack_direction(parse_packdirection(&pack_direction)?); },
     });
 
-    systray::maintain_menubar(w.clone());
-    Ok(w)
+    systray::maintain_menubar(gtk_widget.clone());
+    Ok(gtk_widget)
 }
 
 /// @var orientation - "vertical", "v", "horizontal", "h"
diff --git a/crates/notifier_host/src/error.rs b/crates/notifier_host/src/error.rs
deleted file mode 100644
index a8a2d6f8..00000000
--- a/crates/notifier_host/src/error.rs
+++ /dev/null
@@ -1,11 +0,0 @@
-use thiserror::Error;
-
-#[derive(Error, Debug)]
-pub enum Error {
-    #[error("Dbus connection error")]
-    DbusError(#[from] zbus::Error),
-    #[error("Service path {0} was not understood")]
-    DbusAddressError(String),
-}
-
-pub type Result<T> = std::result::Result<T, Error>;
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index 962ac4de..e6afc874 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -7,10 +7,8 @@ pub trait Host {
     fn remove_item(&mut self, id: &str);
 }
 
-/// Attach to dbus and forward events to Host.
-///
-/// This async function won't complete unless an error occurs.
-pub async fn host_on(host: &mut dyn Host, con: &zbus::Connection) -> Result<()> {
+/// Register this connection as a StatusNotifierHost.
+pub async fn register_host(con: &zbus::Connection) -> zbus::Result<dbus::StatusNotifierWatcherProxy> {
     // From <https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierHost/>:
     //
     // Instances of this service are registered on the Dbus session bus, under a name on the
@@ -40,6 +38,10 @@ pub async fn host_on(host: &mut dyn Host, con: &zbus::Connection) -> Result<()>
     let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;
     snw.register_status_notifier_host(&wellknown_name).await?;
 
+    Ok(snw)
+}
+
+pub async fn serve_host_forever_on(host: &mut dyn Host, snw: dbus::StatusNotifierWatcherProxy<'_>) -> zbus::Result<()> {
     enum ItemEvent {
         NewItem(dbus::StatusNotifierItemRegistered),
         GoneItem(dbus::StatusNotifierItemUnregistered),
@@ -51,7 +53,7 @@ pub async fn host_on(host: &mut dyn Host, con: &zbus::Connection) -> Result<()>
 
     // initial items first
     for svc in snw.registered_status_notifier_items().await? {
-        let item = Item::from_address(&con, &svc).await?;
+        let item = Item::from_address(snw.connection(), &svc).await?;
         host.add_item(&svc, item);
     }
 
@@ -63,7 +65,7 @@ pub async fn host_on(host: &mut dyn Host, con: &zbus::Connection) -> Result<()>
         match ev {
             ItemEvent::NewItem(sig) => {
                 let args = sig.args()?;
-                let item = Item::from_address(&con, args.service).await?;
+                let item = Item::from_address(snw.connection(), args.service).await?;
                 host.add_item(args.service, item);
             },
             ItemEvent::GoneItem(sig) => {
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index 21df0054..75555e04 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -5,6 +5,11 @@ use gtk::{self, prelude::*};
 use zbus::export::ordered_stream::OrderedStreamExt;
 use tokio::sync::watch;
 
+/// Recognised values of org.freedesktop.StatusNotifierItem.Status
+///
+/// See
+/// <https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierItem/#org.freedesktop.statusnotifieritem.status>
+/// for details.
 #[derive(Debug, Clone, Copy)]
 pub enum Status {
     /// The item doesn't convey important information to the user, it can be considered an "idle"
@@ -42,7 +47,7 @@ pub struct Item {
 /// path.
 ///
 /// Original logic from <https://github.com/oknozor/stray/blob/main/stray/src/notifier_watcher/notifier_address.rs>
-fn split_service_name(service: &str) -> Result<(String, String)> {
+fn split_service_name(service: &str) -> zbus::Result<(String, String)> {
     if let Some((addr, path)) = service.split_once('/') {
         Ok((addr.to_owned(), format!("/{}", path)))
     } else if service.contains(':') {
@@ -52,15 +57,15 @@ fn split_service_name(service: &str) -> Result<(String, String)> {
         if let Some(addr) = addr {
             Ok((addr.to_owned(), "/StatusNotifierItem".to_owned()))
         } else {
-            Err(Error::DbusAddressError(service.to_owned()))
+            Err(zbus::Error::Address(service.to_owned()))
         }
     } else {
-        Err(Error::DbusAddressError(service.to_owned()))
+        Err(zbus::Error::Address(service.to_owned()))
     }
 }
 
 impl Item {
-    pub async fn from_address(con: &zbus::Connection, addr: &str) -> Result<Self> {
+    pub async fn from_address(con: &zbus::Connection, addr: &str) -> zbus::Result<Self> {
         let (addr, path) = split_service_name(addr)?;
         let sni = dbus::StatusNotifierItemProxy::builder(con)
             .destination(addr)?
@@ -193,7 +198,7 @@ impl Item {
         }
     }
 
-    pub async fn menu(&self) -> Result<gtk::Menu> {
+    pub async fn menu(&self) -> zbus::Result<gtk::Menu> {
         // TODO better handling if menu() method doesn't exist
         let menu = dbusmenu_gtk3::Menu::new(self.sni.destination(), &self.sni.menu().await?);
         Ok(menu.upcast())
diff --git a/crates/notifier_host/src/lib.rs b/crates/notifier_host/src/lib.rs
index d88a6afd..3ccc94b3 100644
--- a/crates/notifier_host/src/lib.rs
+++ b/crates/notifier_host/src/lib.rs
@@ -1,8 +1,5 @@
 pub mod dbus;
 
-mod error;
-pub use error::*;
-
 mod host;
 pub use host::*;
 
diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index db40099f..adb60ae9 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -231,3 +231,24 @@ impl Watcher {
         ).await
     }
 }
+
+/// Start a StatusNotifierWatcher on this connection.
+pub async fn watcher_on(con: &zbus::Connection) -> zbus::Result<()> {
+    if !con.object_server().at(WATCHER_OBJECT_NAME, Watcher::new()).await? {
+        // There's already something at this object
+        // TODO better handling?
+        return Err(zbus::Error::Failure(format!("Interface already exists at object {}", WATCHER_OBJECT_NAME)))
+    }
+
+    use zbus::fdo::*;
+    match con.request_name_with_flags(WATCHER_BUS_NAME, [RequestNameFlags::DoNotQueue].into_iter().collect()).await? {
+        RequestNameReply::PrimaryOwner => return Ok(()),
+        RequestNameReply::Exists => {},
+        RequestNameReply::AlreadyOwner => {}, // TODO should this return
+        RequestNameReply::InQueue => panic!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
+    }
+
+    // TODO should we queue?
+
+    Ok(())
+}

From 93f0ac9005b9868d1900ca9e666e06e079f88789 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sun, 9 Apr 2023 20:04:38 +1000
Subject: [PATCH 11/30] Handle errors better

---
 crates/eww/src/main.rs              |  5 +++-
 crates/notifier_host/src/host.rs    | 38 +++++++++++++++++++++++------
 crates/notifier_host/src/watcher.rs |  8 +++---
 3 files changed, 40 insertions(+), 11 deletions(-)

diff --git a/crates/eww/src/main.rs b/crates/eww/src/main.rs
index 1e61c3bf..07daa526 100644
--- a/crates/eww/src/main.rs
+++ b/crates/eww/src/main.rs
@@ -45,7 +45,10 @@ fn main() {
     if std::env::var("RUST_LOG").is_ok() {
         pretty_env_logger::init_timed();
     } else {
-        pretty_env_logger::formatted_timed_builder().filter(Some("eww"), log_level_filter).init();
+        pretty_env_logger::formatted_timed_builder()
+            .filter(Some("eww"), log_level_filter)
+            .filter(Some("notifier_host"), log_level_filter)
+            .init();
     }
 
     #[allow(unused)]
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index e6afc874..860ab1ec 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -51,10 +51,19 @@ pub async fn serve_host_forever_on(host: &mut dyn Host, snw: dbus::StatusNotifie
     let new_items = snw.receive_status_notifier_item_registered().await?;
     let gone_items = snw.receive_status_notifier_item_unregistered().await?;
 
+    let mut item_names = std::collections::HashSet::new();
+
     // initial items first
     for svc in snw.registered_status_notifier_items().await? {
-        let item = Item::from_address(snw.connection(), &svc).await?;
-        host.add_item(&svc, item);
+        match Item::from_address(snw.connection(), &svc).await {
+            Ok(item) => {
+                item_names.insert(svc.to_owned());
+                host.add_item(&svc, item);
+            },
+            Err(e) => {
+                log::warn!("Could not create StatusNotifierItem from address {:?}: {:?}", svc, e);
+            },
+        }
     }
 
     let mut ev_stream = ordered_stream::join(
@@ -64,16 +73,31 @@ pub async fn serve_host_forever_on(host: &mut dyn Host, snw: dbus::StatusNotifie
     while let Some(ev) = ev_stream.next().await {
         match ev {
             ItemEvent::NewItem(sig) => {
-                let args = sig.args()?;
-                let item = Item::from_address(snw.connection(), args.service).await?;
-                host.add_item(args.service, item);
+                let svc = sig.args()?.service;
+                if item_names.contains(svc) {
+                    log::warn!("Got duplicate new item: {:?}", svc);
+                } else {
+                    match Item::from_address(snw.connection(), svc).await {
+                        Ok(item) => {
+                            item_names.insert(svc.to_owned());
+                            host.add_item(svc, item);
+                        },
+                        Err(e) => {
+                            log::warn!("Could not create StatusNotifierItem from address {:?}: {:?}", svc, e);
+                        },
+                    }
+                }
             },
             ItemEvent::GoneItem(sig) => {
-                let args = sig.args()?;
-                host.remove_item(args.service);
+                let svc = sig.args()?.service;
+                if item_names.remove(svc) {
+                    host.remove_item(svc);
+                }
             },
         }
     }
 
+    // TODO handle running out of events? why could this happen?
+
     Ok(())
 }
diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index adb60ae9..197fa652 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -125,14 +125,16 @@ impl Watcher {
         #[zbus(signal_context)] ctxt: zbus::SignalContext<'_>,
     ) -> zbus::fdo::Result<()> {
         let (service, objpath) = parse_service(service);
-        let service = if let Some(x) = service {
-            x.to_owned()
+        let service: zbus::names::UniqueName<'_> = if let Some(x) = service {
+            let dbus = zbus::fdo::DBusProxy::new(&con).await?;
+            dbus.get_name_owner(x).await?.into_inner()
         } else if let Some(sender) = hdr.sender()? {
-            sender.to_owned().into()
+            sender.to_owned()
         } else {
             log::warn!("register_status_notifier_item: unknown sender");
             return Err(zbus::fdo::Error::InvalidArgs("Unknown bus address".into()));
         };
+        let service = zbus::names::BusName::Unique(service);
 
         let item = format!("{}{}", service, objpath);
         log::info!("new item: {}", item);

From 0087c643502ccf1b6a4f6da8030fe53fffa9282b Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sun, 9 Apr 2023 20:52:01 +1000
Subject: [PATCH 12/30] Refactor service parsing

---
 crates/notifier_host/src/watcher.rs | 60 +++++++++++++++++------------
 1 file changed, 36 insertions(+), 24 deletions(-)

diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index 197fa652..3e86423d 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -5,13 +5,42 @@ use zbus::export::ordered_stream::OrderedStreamExt;
 pub const WATCHER_BUS_NAME: &'static str = "org.kde.StatusNotifierWatcher";
 pub const WATCHER_OBJECT_NAME: &'static str = "/StatusNotifierWatcher";
 
-fn parse_service(service: &str) -> (Option<zbus::names::BusName<'_>>, &str) {
+async fn parse_service<'a>(
+    service: &'a str,
+    hdr: zbus::MessageHeader<'_>,
+    con: &zbus::Connection,
+) -> zbus::fdo::Result<(zbus::names::UniqueName<'static>, &'a str)>
+{
     if service.starts_with("/") {
         // they sent us just the object path :(
-        (None, service)
+        if let Some(sender) = hdr.sender()? {
+            Ok((sender.to_owned(), service))
+        } else {
+            log::warn!("unknown sender");
+            Err(zbus::fdo::Error::InvalidArgs("Unknown bus address".into()))
+        }
     } else {
-        // should be a bus name
-        (service.try_into().ok(), "/StatusNotifierItem")
+        let busname: zbus::names::BusName = match service.try_into() {
+            Ok(x) => x,
+            Err(e) => {
+                log::warn!("received invalid bus name {:?}: {}", service, e);
+                return Err(zbus::fdo::Error::InvalidArgs(e.to_string()));
+            },
+        };
+
+        if let zbus::names::BusName::Unique(unique) = busname {
+            Ok((unique.to_owned(), "/StatusNotifierItem"))
+        } else {
+            // unwrap: we should always be able to access the dbus interface
+            let dbus = zbus::fdo::DBusProxy::new(&con).await.unwrap();
+            match dbus.get_name_owner(busname).await {
+                Ok(owner) => Ok((owner.into_inner(), "/StatusNotifierItem")),
+                Err(e) => {
+                    log::warn!("failed to get owner of {:?}: {}", service, e);
+                    Err(e)
+                }
+            }
+        }
     }
 }
 
@@ -56,15 +85,7 @@ impl Watcher {
         #[zbus(connection)] con: &zbus::Connection,
         #[zbus(signal_context)] ctxt: zbus::SignalContext<'_>,
     ) -> zbus::fdo::Result<()> {
-        let (service, _) = parse_service(service);
-        let service = if let Some(x) = service {
-            x.to_owned()
-        } else if let Some(sender) = hdr.sender()? {
-            sender.to_owned().into()
-        } else {
-            log::warn!("register_status_notifier_host: unknown sender");
-            return Err(zbus::fdo::Error::InvalidArgs("Unknown bus address".into()));
-        };
+        let (service, _) = parse_service(service, hdr, con).await?;
         log::info!("new host: {}", service);
 
         {
@@ -83,7 +104,7 @@ impl Watcher {
             let ctxt = ctxt.to_owned();
             let con = con.to_owned();
             async move {
-                wait_for_service_exit(con.clone(), service.as_ref()).await.unwrap();
+                wait_for_service_exit(con.clone(), service.as_ref().into()).await.unwrap();
                 log::info!("lost host: {}", service);
 
                 {
@@ -124,16 +145,7 @@ impl Watcher {
         #[zbus(connection)] con: &zbus::Connection,
         #[zbus(signal_context)] ctxt: zbus::SignalContext<'_>,
     ) -> zbus::fdo::Result<()> {
-        let (service, objpath) = parse_service(service);
-        let service: zbus::names::UniqueName<'_> = if let Some(x) = service {
-            let dbus = zbus::fdo::DBusProxy::new(&con).await?;
-            dbus.get_name_owner(x).await?.into_inner()
-        } else if let Some(sender) = hdr.sender()? {
-            sender.to_owned()
-        } else {
-            log::warn!("register_status_notifier_item: unknown sender");
-            return Err(zbus::fdo::Error::InvalidArgs("Unknown bus address".into()));
-        };
+        let (service, objpath) = parse_service(service, hdr, con).await?;
         let service = zbus::names::BusName::Unique(service);
 
         let item = format!("{}{}", service, objpath);

From d7f5049aadd504f6479c4a24b8462a2e9282640c Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Mon, 10 Apr 2023 16:58:26 +1000
Subject: [PATCH 13/30] Avoid duplicate dbus connections

---
 crates/eww/src/widgets/systray.rs   | 38 +++++++++++++++++++++----
 crates/notifier_host/src/host.rs    | 44 ++++++++++++-----------------
 crates/notifier_host/src/watcher.rs |  5 ++--
 3 files changed, 53 insertions(+), 34 deletions(-)

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 3c3521eb..76be2fa5 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -56,19 +56,45 @@ impl notifier_host::Host for Host {
     }
 }
 
-pub fn maintain_menubar(menubar: gtk::MenuBar) {
-    // TODO avoid having too many zbus::Connection instances
+struct DBusGlobalState {
+    con: zbus::Connection,
+    name: zbus::names::WellKnownName<'static>,
+}
 
-    menubar.show_all();
-    glib::MainContext::default().spawn_local(async move {
+async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
+    use tokio::sync::Mutex;
+    use std::sync::{Weak, Arc};
+    use once_cell::sync::Lazy;
+    static DBUS_STATE: Lazy<Mutex<Weak<DBusGlobalState>>> = Lazy::new(Default::default);
+
+    let mut dbus_state = DBUS_STATE.lock().await;
+    if let Some(state) = dbus_state.upgrade() {
+        state
+    } else {
+        // TODO error handling?
         let con = zbus::Connection::session().await.unwrap();
         notifier_host::watcher_on(&con).await.unwrap();
 
-        let snw = notifier_host::register_host(&con).await.unwrap();
+        let name = notifier_host::attach_new_wellknown_name(&con).await.unwrap();
+
+        let arc = Arc::new(DBusGlobalState {
+            con,
+            name,
+        });
+        *dbus_state = Arc::downgrade(&arc);
+
+        arc
+    }
+}
+
+pub fn maintain_menubar(menubar: gtk::MenuBar) {
+    menubar.show_all();
+    glib::MainContext::default().spawn_local(async move {
         let mut host = Host {
             menubar,
             items: std::collections::HashMap::new(),
         };
-        notifier_host::serve_host_forever_on(&mut host, snw).await.unwrap();
+        let s = &dbus_state().await;
+        notifier_host::run_host_forever(&mut host, &s.con, &s.name).await.unwrap();
     });
 }
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index 860ab1ec..e16eb2e2 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -7,41 +7,33 @@ pub trait Host {
     fn remove_item(&mut self, id: &str);
 }
 
-/// Register this connection as a StatusNotifierHost.
-pub async fn register_host(con: &zbus::Connection) -> zbus::Result<dbus::StatusNotifierWatcherProxy> {
-    // From <https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierHost/>:
-    //
-    // Instances of this service are registered on the Dbus session bus, under a name on the
-    // form org.freedesktop.StatusNotifierHost-id where id is an unique identifier, that keeps
-    // the names unique on the bus, such as the process-id of the application or another type
-    // of identifier if more that one StatusNotifierHost is registered by the same process.
-
-    // pick a new wellknown_name
+/// Add a new well-known name of format `org.freedesktop.StatusNotifierHost-{pid}-{nr}` for this connection.
+pub async fn attach_new_wellknown_name(con: &zbus::Connection) -> zbus::Result<zbus::names::WellKnownName<'static>> {
     let pid = std::process::id();
     let mut i = 0;
-    let wellknown_name = loop {
-        let wellknown_name = format!("org.freedesktop.StatusNotifierHost-{}-{}", pid, i);
-        let flags = [zbus::fdo::RequestNameFlags::DoNotQueue];
-
+    let wellknown = loop {
         use zbus::fdo::RequestNameReply::*;
-        match con.request_name_with_flags(wellknown_name.as_str(), flags.into_iter().collect()).await? {
-            PrimaryOwner => break wellknown_name,
-            Exists => {},
-            AlreadyOwner => {}, // we choose to not use an existing owner, is this correct?
-            InQueue => panic!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
-        };
 
         i += 1;
+        let wellknown = format!("org.freedesktop.StatusNotifierHost-{}-{}", pid, i);
+        let wellknown: zbus::names::WellKnownName = wellknown.try_into().expect("generated well-known name is invalid");
+
+        let flags = [zbus::fdo::RequestNameFlags::DoNotQueue];
+        match con.request_name_with_flags(&wellknown, flags.into_iter().collect()).await? {
+            PrimaryOwner => break wellknown,
+            Exists => {},
+            AlreadyOwner => {},
+            InQueue => unreachable!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
+        };
     };
+    Ok(wellknown)
+}
 
+pub async fn run_host_forever(host: &mut dyn Host, con: &zbus::Connection, name: &zbus::names::WellKnownName<'_>) -> zbus::Result<()> {
     // register ourself to StatusNotifierWatcher
     let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;
-    snw.register_status_notifier_host(&wellknown_name).await?;
-
-    Ok(snw)
-}
+    snw.register_status_notifier_host(&name).await?;
 
-pub async fn serve_host_forever_on(host: &mut dyn Host, snw: dbus::StatusNotifierWatcherProxy<'_>) -> zbus::Result<()> {
     enum ItemEvent {
         NewItem(dbus::StatusNotifierItemRegistered),
         GoneItem(dbus::StatusNotifierItemUnregistered),
@@ -75,7 +67,7 @@ pub async fn serve_host_forever_on(host: &mut dyn Host, snw: dbus::StatusNotifie
             ItemEvent::NewItem(sig) => {
                 let svc = sig.args()?.service;
                 if item_names.contains(svc) {
-                    log::warn!("Got duplicate new item: {:?}", svc);
+                    log::info!("Got duplicate new item: {:?}", svc);
                 } else {
                     match Item::from_address(snw.connection(), svc).await {
                         Ok(item) => {
diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index 3e86423d..0d2aac67 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -149,15 +149,16 @@ impl Watcher {
         let service = zbus::names::BusName::Unique(service);
 
         let item = format!("{}{}", service, objpath);
-        log::info!("new item: {}", item);
 
         {
             let mut items = self.items.lock().unwrap();
             if !items.insert(item.clone()) {
                 // we're already tracking them
+                log::info!("new item: {} (duplicate)", item);
                 return Ok(())
             }
         }
+        log::info!("new item: {}", item);
 
         self.registered_status_notifier_items_changed(&ctxt).await?;
         Watcher::status_notifier_item_registered(&ctxt, service.as_ref()).await?;
@@ -259,7 +260,7 @@ pub async fn watcher_on(con: &zbus::Connection) -> zbus::Result<()> {
         RequestNameReply::PrimaryOwner => return Ok(()),
         RequestNameReply::Exists => {},
         RequestNameReply::AlreadyOwner => {}, // TODO should this return
-        RequestNameReply::InQueue => panic!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
+        RequestNameReply::InQueue => unreachable!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
     }
 
     // TODO should we queue?

From c9369c25b7f7d39638d139ffe5bd3c6d9527066a Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Mon, 10 Apr 2023 17:19:42 +1000
Subject: [PATCH 14/30] Fix watcher producing bad items

---
 crates/notifier_host/src/watcher.rs | 28 +++++++++++++++++-----------
 1 file changed, 17 insertions(+), 11 deletions(-)

diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index 0d2aac67..31238efe 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -88,15 +88,18 @@ impl Watcher {
         let (service, _) = parse_service(service, hdr, con).await?;
         log::info!("new host: {}", service);
 
-        {
+        let added_first = {
             let mut hosts = self.hosts.lock().unwrap();
             if !hosts.insert(service.to_string()) {
                 // we're already tracking them
                 return Ok(())
             }
-        }
+            hosts.len() == 1
+        };
 
-        self.is_status_notifier_host_registered_changed(&ctxt).await?;
+        if added_first {
+            self.is_status_notifier_host_registered_changed(&ctxt).await?;
+        }
         Watcher::status_notifier_host_registered(&ctxt).await?;
 
         self.tasks.spawn({
@@ -107,12 +110,15 @@ impl Watcher {
                 wait_for_service_exit(con.clone(), service.as_ref().into()).await.unwrap();
                 log::info!("lost host: {}", service);
 
-                {
+                let removed_last = {
                     let mut hosts = hosts.lock().unwrap();
-                    hosts.remove(service.as_str());
-                }
+                    let did_remove = hosts.remove(service.as_str());
+                    did_remove && hosts.is_empty()
+                };
 
-                Watcher::is_status_notifier_host_registered_refresh(&ctxt).await.unwrap();
+                if removed_last {
+                    Watcher::is_status_notifier_host_registered_refresh(&ctxt).await.unwrap();
+                }
                 Watcher::status_notifier_host_unregistered(&ctxt).await.unwrap();
             }
         });
@@ -161,7 +167,7 @@ impl Watcher {
         log::info!("new item: {}", item);
 
         self.registered_status_notifier_items_changed(&ctxt).await?;
-        Watcher::status_notifier_item_registered(&ctxt, service.as_ref()).await?;
+        Watcher::status_notifier_item_registered(&ctxt, item.as_ref()).await?;
 
         self.tasks.spawn({
             let items = self.items.clone();
@@ -177,7 +183,7 @@ impl Watcher {
                 }
 
                 Watcher::registered_status_notifier_items_refresh(&ctxt).await.unwrap();
-                Watcher::status_notifier_item_unregistered(&ctxt, service.as_ref()).await.unwrap();
+                Watcher::status_notifier_item_unregistered(&ctxt, item.as_ref()).await.unwrap();
             }
         });
 
@@ -186,11 +192,11 @@ impl Watcher {
 
     /// StatusNotifierItemRegistered signal
     #[dbus_interface(signal)]
-    async fn status_notifier_item_registered(ctxt: &zbus::SignalContext<'_>, service: zbus::names::BusName<'_>) -> zbus::Result<()>;
+    async fn status_notifier_item_registered(ctxt: &zbus::SignalContext<'_>, service: &str) -> zbus::Result<()>;
 
     /// StatusNotifierItemUnregistered signal
     #[dbus_interface(signal)]
-    async fn status_notifier_item_unregistered(ctxt: &zbus::SignalContext<'_>, service: zbus::names::BusName<'_>) -> zbus::Result<()>;
+    async fn status_notifier_item_unregistered(ctxt: &zbus::SignalContext<'_>, service: &str) -> zbus::Result<()>;
 
     /// RegisteredStatusNotifierItems property
     #[dbus_interface(property)]

From 64e2917d7b3f921b1419810d3cf7ea26eeb52848 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Mon, 10 Apr 2023 22:06:42 +1000
Subject: [PATCH 15/30] Handle zbus::Error::NameTaken

---
 crates/notifier_host/src/watcher.rs | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index 31238efe..256c7e35 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -261,15 +261,12 @@ pub async fn watcher_on(con: &zbus::Connection) -> zbus::Result<()> {
         return Err(zbus::Error::Failure(format!("Interface already exists at object {}", WATCHER_OBJECT_NAME)))
     }
 
-    use zbus::fdo::*;
-    match con.request_name_with_flags(WATCHER_BUS_NAME, [RequestNameFlags::DoNotQueue].into_iter().collect()).await? {
-        RequestNameReply::PrimaryOwner => return Ok(()),
-        RequestNameReply::Exists => {},
-        RequestNameReply::AlreadyOwner => {}, // TODO should this return
-        RequestNameReply::InQueue => unreachable!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
-    }
-
-    // TODO should we queue?
+    // TODO should we queue if we couldn't take the name?
 
-    Ok(())
+    use zbus::fdo::{RequestNameFlags, RequestNameReply};
+    match con.request_name_with_flags(WATCHER_BUS_NAME, [RequestNameFlags::DoNotQueue].into_iter().collect()).await {
+        Ok(RequestNameReply::PrimaryOwner) => Ok(()),
+        Ok(_) | Err(zbus::Error::NameTaken) => Ok(()), // defer to existing
+        Err(e) => Err(e),
+    }
 }

From 5f8b38dc8b1ee7b48d10f16a0046e363e446709c Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Mon, 10 Apr 2023 22:51:35 +1000
Subject: [PATCH 16/30] Refactor icon loading & don't panic on zoom

---
 crates/notifier_host/src/item.rs | 113 +++++++++++++++++++++++--------
 1 file changed, 86 insertions(+), 27 deletions(-)

diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index 75555e04..d0f4e721 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -116,22 +116,43 @@ impl Item {
 
 #[derive(thiserror::Error, Debug)]
 pub enum IconError {
-    #[error("Dbus error")]
-    DbusError(#[from] zbus::Error),
-    #[error("Failed to load icon {icon_name:?} from theme {theme_path:?}")]
-    LoadIconFromTheme {
-        icon_name: String,
-        theme_path: String,
-        source: gtk::glib::Error,
+    #[error("unhandled dbus error while calling {bus_name}: {err}")]
+    DBusError {
+        #[source] err: zbus::Error,
+        bus_name: zbus::names::BusName<'static>,
     },
-    #[error("Failed to load icon {icon_name:?} from default theme")]
-    LoadIconFromDefaultTheme {
+    #[error("failed to load icon {icon_name:?} from theme {theme_path:?}")]
+    LoadIconFromTheme {
         icon_name: String,
+        theme_path: Option<String>,
         source: gtk::glib::Error,
     },
+    #[error("no icon available")]
+    NotAvailable,
+}
+
+/// Get the fallback GTK icon
+async fn fallback_icon(size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+    // TODO downgrade from panic to error return?
+    let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
+    return match theme.load_icon("image-missing", size, gtk::IconLookupFlags::FORCE_SIZE) {
+        Err(e) => Err(IconError::LoadIconFromTheme {
+            icon_name: "image-missing".to_owned(),
+            theme_path: None,
+            source: e,
+        }),
+        Ok(pb) => Ok(pb.unwrap()),
+    }
 }
 
 impl Item {
+    fn to_dbus_err(&self, err: zbus::Error) -> IconError {
+        IconError::DBusError {
+            err,
+            bus_name: self.sni.destination().to_owned()
+        }
+    }
+
     pub fn load_pixmap(width: i32, height: i32, mut data: Vec<u8>) -> gtk::Image {
         // We need to convert data from ARGB32 to RGBA32
         for chunk in data.chunks_mut(4) {
@@ -157,22 +178,35 @@ impl Item {
         gtk::Image::from_pixbuf(Some(&pixmap))
     }
 
-    pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-        let icon_name = self.sni.icon_name().await?;
-        let icon_theme_path = self.sni.icon_theme_path().await?;
+    async fn icon_from_name(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+        // TODO better handling of icon_name failure instead of punting it to the caller
+        let icon_name = match self.sni.icon_name().await {
+            Ok(s) if s == "" => return Err(IconError::NotAvailable),
+            Ok(s) => s,
+            Err(e) => return Err(self.to_dbus_err(e)),
+        };
+
+        let icon_theme_path = match self.sni.icon_theme_path().await {
+            Ok(p) => p,
+            Err(zbus::Error::FDO(e)) => match *e {
+                zbus::fdo::Error::UnknownProperty(_) => "".into(),
+                _ => return Err(self.to_dbus_err(zbus::Error::FDO(e))),
+            },
+            Err(e) => return Err(self.to_dbus_err(e)),
+        };
 
         if icon_theme_path != "" {
-            // icon supplied a theme path, so only look there
+            // icon supplied a theme path, so only look there (w/ fallback)
             let theme = gtk::IconTheme::new();
             theme.prepend_search_path(&icon_theme_path);
 
             return match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
                 Err(e) => Err(IconError::LoadIconFromTheme {
                     icon_name,
-                    theme_path: icon_theme_path,
+                    theme_path: Some(icon_theme_path),
                     source: e,
                 }),
-                Ok(pb) => return Ok(pb.unwrap()),
+                Ok(pb) => return Ok(pb.expect("no pixbuf from theme.load_icon despite no error")),
             }
         }
 
@@ -180,22 +214,47 @@ impl Item {
         let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
         match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
             // TODO specifically match on icon missing here
-            Err(e) => log::warn!("Could not find icon {:?} in default theme: {}", &icon_name, e),
-            Ok(pb) => return Ok(pb.unwrap()),
+            Err(e) => {
+                log::warn!("Could not find icon {:?} in default theme: {}", &icon_name, e);
+                Err(IconError::LoadIconFromTheme {
+                    icon_name,
+                    theme_path: None,
+                    source: e,
+                })
+            },
+            Ok(pb) => Ok(pb.unwrap()),
         }
+    }
 
-        // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are available."
-        // TODO icon_pixmap
+    async fn icon_from_pixmap(&self, _size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+        let _pixmap = match self.sni.icon_pixmap().await {
+            Ok(p) => p,
+            Err(e) => return Err(self.to_dbus_err(e)),
+        };
 
-        // fallback to default icon
-        let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
-        return match theme.load_icon("image-missing", size, gtk::IconLookupFlags::FORCE_SIZE) {
-            Err(e) => Err(IconError::LoadIconFromDefaultTheme {
-                icon_name: "image-missing".to_owned(),
-                source: e,
-            }),
-            Ok(pb) => return Ok(pb.unwrap()),
+        // TODO
+        Err(IconError::NotAvailable)
+    }
+
+    pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+        // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are
+        // available."
+
+        match self.icon_from_name(size).await {
+            Ok(pb) => return Ok(pb),
+            // don't handle unknown dbus error
+            err @ Err(IconError::DBusError { .. }) => return err,
+            Err(_) => {},
+        };
+
+        match self.icon_from_pixmap(size).await {
+            Ok(pb) => return Ok(pb),
+            // don't handle unknown dbus error
+            err @ Err(IconError::DBusError { .. }) => return err,
+            Err(_) => {},
         }
+
+        fallback_icon(size).await
     }
 
     pub async fn menu(&self) -> zbus::Result<gtk::Menu> {

From fa3a90b4c3295c8eee7ae84a02b1a010ea1e32ab Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Tue, 13 Jun 2023 11:13:07 +1000
Subject: [PATCH 17/30] Implement pixbuf icons
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Co-authored-by: Bojan Nemčić <bnemcic@gmail.com>
---
 crates/notifier_host/src/item.rs | 32 ++++++++++++++++++++------------
 1 file changed, 20 insertions(+), 12 deletions(-)

diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index d0f4e721..d70684ef 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -50,7 +50,7 @@ pub struct Item {
 fn split_service_name(service: &str) -> zbus::Result<(String, String)> {
     if let Some((addr, path)) = service.split_once('/') {
         Ok((addr.to_owned(), format!("/{}", path)))
-    } else if service.contains(':') {
+    } else if service.contains(':') { // TODO why?
         let addr = service.split(':').skip(1).next();
         // Some StatusNotifierItems will not return an object path, in that case we fallback
         // to the default path.
@@ -153,7 +153,7 @@ impl Item {
         }
     }
 
-    pub fn load_pixmap(width: i32, height: i32, mut data: Vec<u8>) -> gtk::Image {
+    pub fn load_pixbuf(width: i32, height: i32, mut data: Vec<u8>) -> gtk::gdk_pixbuf::Pixbuf {
         // We need to convert data from ARGB32 to RGBA32
         for chunk in data.chunks_mut(4) {
             let a = chunk[0];
@@ -166,7 +166,7 @@ impl Item {
             chunk[3] = a;
         }
 
-        let pixmap = gtk::gdk_pixbuf::Pixbuf::from_bytes(
+        gtk::gdk_pixbuf::Pixbuf::from_bytes(
             &gtk::glib::Bytes::from_owned(data),
             gtk::gdk_pixbuf::Colorspace::Rgb,
             true,
@@ -174,8 +174,7 @@ impl Item {
             width,
             height,
             width * 4,
-        );
-        gtk::Image::from_pixbuf(Some(&pixmap))
+        )
     }
 
     async fn icon_from_name(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
@@ -226,14 +225,23 @@ impl Item {
         }
     }
 
-    async fn icon_from_pixmap(&self, _size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-        let _pixmap = match self.sni.icon_pixmap().await {
-            Ok(p) => p,
-            Err(e) => return Err(self.to_dbus_err(e)),
-        };
+    async fn icon_from_pixmap(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+        match self.sni.icon_pixmap().await {
+            Ok(ps) => {
+                for (width, height, data) in ps {
+                    if width == size && height == size {
+                        return Ok(Self::load_pixbuf(width, height, data))
+                    }
+                }
 
-        // TODO
-        Err(IconError::NotAvailable)
+                Err(IconError::NotAvailable)
+            },
+            Err(zbus::Error::FDO(e)) => match *e {
+                zbus::fdo::Error::UnknownMethod(_) => Err(IconError::NotAvailable),
+                _ => return Err(self.to_dbus_err(zbus::Error::FDO(e))),
+            },
+            Err(e) => Err(self.to_dbus_err(e)),
+        }
     }
 
     pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {

From 670f8b4e2d69866517e1d55dd3bf417518ac593b Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Tue, 13 Jun 2023 11:31:25 +1000
Subject: [PATCH 18/30] Don't panic on icon/menu error

---
 crates/eww/src/widgets/systray.rs | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 76be2fa5..eab4885d 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -36,13 +36,18 @@ impl notifier_host::Host for Host {
 
         // other initialisation
         glib::MainContext::default().spawn_local({
+            let id = id.to_owned();
             let mi = mi.clone();
             async move {
-                let img = item.icon(24).await.unwrap();
-                icon.set_from_pixbuf(Some(&img));
+                match item.icon(24).await {
+                    Ok(img) => icon.set_from_pixbuf(Some(&img)),
+                    Err(e) => log::warn!("Failed to load icon for {:?}: {}", id, e),
+                }
 
-                let menu = item.menu().await.unwrap();
-                mi.set_submenu(Some(&menu));
+                match item.menu().await {
+                    Ok(menu) => mi.set_submenu(Some(&menu)),
+                    Err(e) => log::warn!("Failed to load menu for {:?}: {}", id, e),
+                }
             }
         });
         mi.show_all();

From 46b3fbb2df1d8c4a3be6c2e66ef5ed4a8bd6fd6d Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Tue, 13 Jun 2023 15:45:14 +1000
Subject: [PATCH 19/30] Improve icon error handling to make discord work

---
 crates/notifier_host/src/item.rs | 61 +++++++++++++++++---------------
 1 file changed, 32 insertions(+), 29 deletions(-)

diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index d70684ef..f179dfaf 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -116,11 +116,12 @@ impl Item {
 
 #[derive(thiserror::Error, Debug)]
 pub enum IconError {
-    #[error("unhandled dbus error while calling {bus_name}: {err}")]
-    DBusError {
-        #[source] err: zbus::Error,
-        bus_name: zbus::names::BusName<'static>,
-    },
+    #[error("failed to get icon name: {0}")]
+    DBusIconName(zbus::Error),
+    #[error("failed to get icon theme path: {0}")]
+    DBusTheme(zbus::Error),
+    #[error("failed to get pixmap: {0}")]
+    DBusPixmap(zbus::Error),
     #[error("failed to load icon {icon_name:?} from theme {theme_path:?}")]
     LoadIconFromTheme {
         icon_name: String,
@@ -146,13 +147,6 @@ async fn fallback_icon(size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf
 }
 
 impl Item {
-    fn to_dbus_err(&self, err: zbus::Error) -> IconError {
-        IconError::DBusError {
-            err,
-            bus_name: self.sni.destination().to_owned()
-        }
-    }
-
     pub fn load_pixbuf(width: i32, height: i32, mut data: Vec<u8>) -> gtk::gdk_pixbuf::Pixbuf {
         // We need to convert data from ARGB32 to RGBA32
         for chunk in data.chunks_mut(4) {
@@ -182,27 +176,30 @@ impl Item {
         let icon_name = match self.sni.icon_name().await {
             Ok(s) if s == "" => return Err(IconError::NotAvailable),
             Ok(s) => s,
-            Err(e) => return Err(self.to_dbus_err(e)),
+            Err(e) => return Err(IconError::DBusIconName(e)),
         };
 
         let icon_theme_path = match self.sni.icon_theme_path().await {
-            Ok(p) => p,
+            Ok(p) if p == "" => None,
+            Ok(p) => Some(p),
             Err(zbus::Error::FDO(e)) => match *e {
-                zbus::fdo::Error::UnknownProperty(_) => "".into(),
-                _ => return Err(self.to_dbus_err(zbus::Error::FDO(e))),
+                zbus::fdo::Error::UnknownProperty(_)
+                | zbus::fdo::Error::InvalidArgs(_)
+                    => None,
+                _ => return Err(IconError::DBusTheme(zbus::Error::FDO(e))),
             },
-            Err(e) => return Err(self.to_dbus_err(e)),
+            Err(e) => return Err(IconError::DBusTheme(e)),
         };
 
-        if icon_theme_path != "" {
+        if let Some(theme_path) = icon_theme_path {
             // icon supplied a theme path, so only look there (w/ fallback)
             let theme = gtk::IconTheme::new();
-            theme.prepend_search_path(&icon_theme_path);
+            theme.prepend_search_path(&theme_path);
 
             return match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
                 Err(e) => Err(IconError::LoadIconFromTheme {
                     icon_name,
-                    theme_path: Some(icon_theme_path),
+                    theme_path: Some(theme_path),
                     source: e,
                 }),
                 Ok(pb) => return Ok(pb.expect("no pixbuf from theme.load_icon despite no error")),
@@ -237,29 +234,35 @@ impl Item {
                 Err(IconError::NotAvailable)
             },
             Err(zbus::Error::FDO(e)) => match *e {
-                zbus::fdo::Error::UnknownMethod(_) => Err(IconError::NotAvailable),
-                _ => return Err(self.to_dbus_err(zbus::Error::FDO(e))),
+                zbus::fdo::Error::UnknownProperty(_)
+                | zbus::fdo::Error::InvalidArgs(_)
+                    => Err(IconError::NotAvailable),
+                _ => Err(IconError::DBusPixmap(zbus::Error::FDO(e))),
             },
-            Err(e) => Err(self.to_dbus_err(e)),
+            Err(e) => Err(IconError::DBusPixmap(e)),
         }
     }
 
     pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+        // TODO make this function retun just Pixbuf instead of a result?
+
         // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are
         // available."
 
         match self.icon_from_name(size).await {
             Ok(pb) => return Ok(pb),
-            // don't handle unknown dbus error
-            err @ Err(IconError::DBusError { .. }) => return err,
-            Err(_) => {},
+            Err(IconError::NotAvailable)
+            | Err(IconError::LoadIconFromTheme { .. })
+                => {},
+            // Don't fail icon loading here -- e.g. discord raises
+            // "org.freedesktop.DBus.Error.Failed: error occurred in Get" but has a valid pixmap
+            Err(e) => log::warn!("failed to get icon by name for {}: {}", self.sni.destination(), e),
         };
 
         match self.icon_from_pixmap(size).await {
             Ok(pb) => return Ok(pb),
-            // don't handle unknown dbus error
-            err @ Err(IconError::DBusError { .. }) => return err,
-            Err(_) => {},
+            Err(IconError::NotAvailable) => {},
+            Err(e) => log::warn!("failed to get icon pixmap for {}: {}", self.sni.destination(), e),
         }
 
         fallback_icon(size).await

From edbe13f87877ca4977aa79777f0af90b5ca8dca8 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Tue, 13 Jun 2023 16:00:15 +1000
Subject: [PATCH 20/30] Update comments

---
 crates/notifier_host/src/item.rs | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index f179dfaf..bc7d7ac4 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -226,6 +226,8 @@ impl Item {
         match self.sni.icon_pixmap().await {
             Ok(ps) => {
                 for (width, height, data) in ps {
+                    // TODO use closest size instead of looking for exact match
+                    // (can be tested with keepassxc, which only provides 48x48 and 22x22 pixmaps)
                     if width == size && height == size {
                         return Ok(Self::load_pixbuf(width, height, data))
                     }
@@ -244,7 +246,8 @@ impl Item {
     }
 
     pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-        // TODO make this function retun just Pixbuf instead of a result?
+        // TODO make this function retun just Pixbuf instead of a result, now that we're handling
+        // all errors here?
 
         // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are
         // available."
@@ -257,7 +260,7 @@ impl Item {
             // Don't fail icon loading here -- e.g. discord raises
             // "org.freedesktop.DBus.Error.Failed: error occurred in Get" but has a valid pixmap
             Err(e) => log::warn!("failed to get icon by name for {}: {}", self.sni.destination(), e),
-        };
+        }
 
         match self.icon_from_pixmap(size).await {
             Ok(pb) => return Ok(pb),

From 0474f6b3495930193546260d5c39c5624c931d16 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Wed, 14 Jun 2023 23:50:27 +1000
Subject: [PATCH 21/30] Big refactor into actor model

---
 crates/eww/src/widgets/def_widget_macro.rs   |   2 +
 crates/eww/src/widgets/systray.rs            | 225 +++++++++++++------
 crates/eww/src/widgets/widget_definitions.rs |  14 +-
 crates/notifier_host/src/item.rs             | 103 +++++----
 4 files changed, 238 insertions(+), 106 deletions(-)

diff --git a/crates/eww/src/widgets/def_widget_macro.rs b/crates/eww/src/widgets/def_widget_macro.rs
index 28280297..da640ca8 100644
--- a/crates/eww/src/widgets/def_widget_macro.rs
+++ b/crates/eww/src/widgets/def_widget_macro.rs
@@ -53,6 +53,8 @@ macro_rules! def_widget {
                                     // values is a map of all the variables that are required to evaluate the
                                     // attributes expression.
 
+                                    // allow $gtk_widget to never be used, by creating a reference that gets immediately discarded
+                                    {&$gtk_widget};
 
                                     // We first initialize all the local variables for all the expected attributes in scope
                                     $(
diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index eab4885d..3bb09407 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -3,64 +3,7 @@
 use gtk::prelude::*;
 use notifier_host;
 
-struct Host {
-    menubar: gtk::MenuBar,
-    items: std::collections::HashMap<String, gtk::MenuItem>,
-}
-
-async fn watch_foreach<T: std::fmt::Debug>(mut rx: tokio::sync::watch::Receiver<T>, mut f: impl FnMut(&T)) {
-    f(&rx.borrow());
-    while rx.changed().await.is_ok() {
-        f(&rx.borrow());
-    }
-}
-
-impl notifier_host::Host for Host {
-    fn add_item(&mut self, id: &str, item: notifier_host::Item) {
-        let mi = gtk::MenuItem::new();
-        self.menubar.add(&mi);
-        if let Some(old_mi) = self.items.insert(id.to_string(), mi.clone()) {
-            self.menubar.remove(&old_mi);
-        }
-
-        // maintain title
-        glib::MainContext::default().spawn_local({
-            let mi = mi.clone();
-            watch_foreach(item.title(), move |title| {
-                mi.set_tooltip_text(Some(title));
-            })
-        });
-
-        let icon = gtk::Image::new();
-        mi.add(&icon);
-
-        // other initialisation
-        glib::MainContext::default().spawn_local({
-            let id = id.to_owned();
-            let mi = mi.clone();
-            async move {
-                match item.icon(24).await {
-                    Ok(img) => icon.set_from_pixbuf(Some(&img)),
-                    Err(e) => log::warn!("Failed to load icon for {:?}: {}", id, e),
-                }
-
-                match item.menu().await {
-                    Ok(menu) => mi.set_submenu(Some(&menu)),
-                    Err(e) => log::warn!("Failed to load menu for {:?}: {}", id, e),
-                }
-            }
-        });
-        mi.show_all();
-    }
-    fn remove_item(&mut self, id: &str) {
-        if let Some(mi) = self.items.get(id) {
-            self.menubar.remove(mi);
-        } else {
-            log::warn!("Tried to remove nonexistent item {:?} from systray", id);
-        }
-    }
-}
-
+// DBus state shared between systray instances, to avoid creating too many connections etc.
 struct DBusGlobalState {
     con: zbus::Connection,
     name: zbus::names::WellKnownName<'static>,
@@ -92,14 +35,166 @@ async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
     }
 }
 
-pub fn maintain_menubar(menubar: gtk::MenuBar) {
-    menubar.show_all();
+pub struct Props {
+    icon_size_tx: tokio::sync::watch::Sender<i32>,
+}
+
+impl Props {
+    pub fn new() -> Self {
+        let (icon_size_tx, _) = tokio::sync::watch::channel(24);
+        Self {
+            icon_size_tx,
+        }
+    }
+
+    pub fn icon_size(&self, value: i32) {
+        let _ = self.icon_size_tx.send_if_modified(|x| {
+            if *x == value {
+                false
+            } else {
+                *x = value;
+                true
+            }
+        });
+    }
+}
+
+struct Tray {
+    menubar: gtk::MenuBar,
+    items: std::collections::HashMap<String, Item>,
+
+    icon_size: tokio::sync::watch::Receiver<i32>,
+}
+
+pub fn spawn_systray(
+    menubar: &gtk::MenuBar,
+    props: &Props,
+) {
+    let mut systray = Tray {
+        menubar: menubar.clone(),
+        items: Default::default(),
+        icon_size: props.icon_size_tx.subscribe(),
+    };
+
     glib::MainContext::default().spawn_local(async move {
-        let mut host = Host {
-            menubar,
-            items: std::collections::HashMap::new(),
-        };
         let s = &dbus_state().await;
-        notifier_host::run_host_forever(&mut host, &s.con, &s.name).await.unwrap();
+        systray.menubar.show();
+        notifier_host::run_host_forever(&mut systray, &s.con, &s.name).await.unwrap();
     });
 }
+
+impl notifier_host::Host for Tray {
+    fn add_item(&mut self, id: &str, item: notifier_host::Item) {
+        let item = Item::new(
+            id.to_owned(),
+            item,
+            self.icon_size.clone()
+        );
+        self.menubar.add(&item.mi);
+        if let Some(old_item) = self.items.insert(id.to_string(), item) {
+            self.menubar.remove(&old_item.mi);
+        }
+    }
+    fn remove_item(&mut self, id: &str) {
+        if let Some(item) = self.items.get(id) {
+            self.menubar.remove(&item.mi);
+        } else {
+            log::warn!("Tried to remove nonexistent item {:?} from systray", id);
+        }
+    }
+}
+
+struct Item {
+    mi: gtk::MenuItem,
+
+    tasks: Vec<glib::SourceId>,
+}
+
+impl Drop for Item {
+    fn drop(&mut self) {
+        for task in self.tasks.drain(..) {
+            // TODO does this abort the task
+            task.remove();
+        }
+    }
+}
+
+impl Item {
+    fn new(
+        id: String,
+        item: notifier_host::Item,
+        mut icon_size: tokio::sync::watch::Receiver<i32>,
+    ) -> Self {
+        let mi = gtk::MenuItem::new();
+        let mut out = Self {
+            mi: mi.clone(),
+            tasks: Vec::new(),
+        };
+
+        out.spawn(async move {
+            // TODO don't unwrap so much
+
+            // init icon
+            let icon = gtk::Image::new();
+            mi.add(&icon);
+            icon.show();
+
+            // init menu
+            match item.menu().await {
+                Ok(m) => mi.set_submenu(Some(&m)),
+                Err(e) => log::warn!("failed to get menu of {}: {}", id, e),
+            }
+
+            // TODO this is a lot of code duplication unfortunately, i'm not really sure how to
+            // refactor without making the borrow checker angry
+
+            // set status
+            match item.status().await.unwrap() {
+                notifier_host::Status::Passive => mi.hide(),
+                notifier_host::Status::Active | notifier_host::Status::NeedsAttention => mi.show(),
+            }
+
+            // set title
+            mi.set_tooltip_text(Some(&item.title().await.unwrap()));
+
+            // set icon
+            match item.icon(*icon_size.borrow_and_update()).await {
+                Ok(p) => icon.set_from_pixbuf(Some(&p)),
+                Err(e) => log::warn!("failed to get icon of {}: {}", id, e),
+            }
+
+            // updates
+            let mut status_updates = item.status_updates();
+            let mut title_updates = item.title_updates();
+
+            loop {
+                tokio::select! {
+                    Ok(_) = status_updates.changed() => {
+                        // set status
+                        match item.status().await.unwrap() {
+                            notifier_host::Status::Passive => mi.hide(),
+                            notifier_host::Status::Active | notifier_host::Status::NeedsAttention => mi.show(),
+                        }
+                    }
+                    Ok(_) = icon_size.changed() => {
+                        // set icon
+                        match item.icon(*icon_size.borrow_and_update()).await {
+                            Ok(p) => icon.set_from_pixbuf(Some(&p)),
+                            Err(e) => log::warn!("failed to get icon of {}: {}", id, e),
+                        }
+                    }
+                    Ok(_) = title_updates.changed() => {
+                        // set title
+                        mi.set_tooltip_text(Some(&item.title().await.unwrap()));
+                    }
+                }
+            }
+        });
+
+        out
+    }
+
+    fn spawn(&mut self, f: impl std::future::Future<Output = ()> + 'static) {
+        self.tasks.push(glib::MainContext::default().spawn_local(f));
+    }
+}
diff --git a/crates/eww/src/widgets/widget_definitions.rs b/crates/eww/src/widgets/widget_definitions.rs
index 795ac42b..21d145bd 100644
--- a/crates/eww/src/widgets/widget_definitions.rs
+++ b/crates/eww/src/widgets/widget_definitions.rs
@@ -1042,13 +1042,25 @@ const WIDGET_NAME_SYSTRAY: &str = "systray";
 /// @desc Tray for system notifier icons
 fn build_systray(bargs: &mut BuilderArgs) -> Result<gtk::MenuBar> {
     let gtk_widget = gtk::MenuBar::new();
+    let props = Rc::new(systray::Props::new());
+    let props_clone = props.clone();
 
+    // copies for def_widget
     def_widget!(bargs, _g, gtk_widget, {
+        // @prop icon-size - size of icons in the tray
+        prop(icon_size: as_i32) {
+            if icon_size <= 0 {
+                log::warn!("Icon size is not a positive number");
+            } else {
+                props.icon_size(icon_size);
+            }
+        },
         // @prop pack-direction - how to arrange tray items
         prop(pack_direction: as_string) { gtk_widget.set_pack_direction(parse_packdirection(&pack_direction)?); },
     });
 
-    systray::maintain_menubar(gtk_widget.clone());
+    systray::spawn_systray(&gtk_widget, &props_clone);
+
     Ok(gtk_widget)
 }
 
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index bc7d7ac4..e5f9a682 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -3,7 +3,7 @@ use crate::*;
 use log;
 use gtk::{self, prelude::*};
 use zbus::export::ordered_stream::OrderedStreamExt;
-use tokio::sync::watch;
+use tokio::{sync::watch, select};
 
 /// Recognised values of org.freedesktop.StatusNotifierItem.Status
 ///
@@ -23,26 +23,23 @@ pub enum Status {
     NeedsAttention,
 }
 
+#[derive(Debug, Clone, PartialEq, Eq)]
+#[non_exhaustive]
+pub struct ParseStatusError;
+
 impl std::str::FromStr for Status {
-    type Err = ();
+    type Err = ParseStatusError;
 
-    fn from_str(s: &str) -> std::result::Result<Self, ()> {
+    fn from_str(s: &str) -> std::result::Result<Self, ParseStatusError> {
         match s {
             "Passive" => Ok(Status::Passive),
             "Active" => Ok(Status::Active),
             "NeedsAttention" => Ok(Status::NeedsAttention),
-            _ => Err(()),
+            _ => Err(ParseStatusError),
         }
     }
 }
 
-#[derive(Clone, Debug)]
-pub struct Item {
-    pub sni: dbus::StatusNotifierItemProxy<'static>,
-    status_rx: watch::Receiver<Status>,
-    title_rx: watch::Receiver<String>,
-}
-
 /// Split a sevice name e.g. `:1.50:/org/ayatana/NotificationItem/nm_applet` into the address and
 /// path.
 ///
@@ -64,6 +61,21 @@ fn split_service_name(service: &str) -> zbus::Result<(String, String)> {
     }
 }
 
+pub struct Item {
+    pub sni: dbus::StatusNotifierItemProxy<'static>,
+
+    status_rx: watch::Receiver<()>,
+    title_rx: watch::Receiver<()>,
+
+    task: tokio::task::JoinHandle<()>,
+}
+
+impl Drop for Item {
+    fn drop(&mut self) {
+        self.task.abort();
+    }
+}
+
 impl Item {
     pub async fn from_address(con: &zbus::Connection, addr: &str) -> zbus::Result<Self> {
         let (addr, path) = split_service_name(addr)?;
@@ -72,46 +84,61 @@ impl Item {
             .path(path)?
             .build()
             .await?;
+        let sni_out = sni.clone();
 
-        let (status_tx, status_rx) = watch::channel(sni.status().await?.parse().unwrap());
-        tokio::spawn({
-            let sni = sni.clone();
-            async move {
-                let mut new_status_stream = sni.receive_new_status().await.unwrap();
-                while let Some(sig) = new_status_stream.next().await {
-                    let args = sig.args().unwrap();
-                    let status: Status = args.status.parse().unwrap();
-                    status_tx.send_replace(status);
-                }
-            }
-        });
+        let (status_tx, status_rx) = watch::channel(());
+        let (title_tx, title_rx) = watch::channel(());
 
-        let (title_tx, title_rx) = watch::channel(sni.title().await?);
-        tokio::spawn({
-            let sni = sni.clone();
-            async move {
-                let mut new_title_stream = sni.receive_new_title().await.unwrap();
-                while let Some(_) = new_title_stream.next().await {
-                    let title = sni.title().await.unwrap();
-                    title_tx.send_replace(title);
+        let task = tokio::spawn(async move {
+            let mut status_updates = sni.receive_new_status().await.unwrap();
+            let mut title_updates = sni.receive_new_title().await.unwrap();
+
+            loop {
+                select! {
+                    _ = status_updates.next() => {
+                        status_tx.send_replace(());
+                    }
+                    _ = title_updates.next() => {
+                        title_tx.send_replace(());
+                    }
                 }
             }
         });
 
         Ok(Item {
-            sni,
+            sni: sni_out,
             status_rx,
             title_rx,
+            task,
         })
     }
 
-    pub fn status(&self) -> watch::Receiver<Status> {
+    /// Get the current status of the item.
+    pub async fn status(&self) -> zbus::Result<Status> {
+        let status = self.sni.status().await?;
+        match status.parse() {
+            Ok(s) => Ok(s),
+            Err(_) => Err(zbus::Error::Failure(format!("Invalid status {:?}", status))),
+        }
+    }
+
+    pub fn status_updates(&self) -> watch::Receiver<()> {
         self.status_rx.clone()
     }
 
-    pub fn title(&self) -> watch::Receiver<String> {
+    pub async fn title(&self) -> zbus::Result<String> {
+        self.sni.title().await
+    }
+
+    pub fn title_updates(&self) -> watch::Receiver<()> {
         self.title_rx.clone()
     }
+
+    pub async fn menu(&self) -> zbus::Result<gtk::Menu> {
+        // TODO better handling if menu() method doesn't exist
+        let menu = dbusmenu_gtk3::Menu::new(self.sni.destination(), &self.sni.menu().await?);
+        Ok(menu.upcast())
+    }
 }
 
 #[derive(thiserror::Error, Debug)]
@@ -186,6 +213,8 @@ impl Item {
                 zbus::fdo::Error::UnknownProperty(_)
                 | zbus::fdo::Error::InvalidArgs(_)
                     => None,
+                // this error is reported by discord, blueman-applet
+                zbus::fdo::Error::Failed(msg) if msg == "error occurred in Get" => None,
                 _ => return Err(IconError::DBusTheme(zbus::Error::FDO(e))),
             },
             Err(e) => return Err(IconError::DBusTheme(e)),
@@ -270,10 +299,4 @@ impl Item {
 
         fallback_icon(size).await
     }
-
-    pub async fn menu(&self) -> zbus::Result<gtk::Menu> {
-        // TODO better handling if menu() method doesn't exist
-        let menu = dbusmenu_gtk3::Menu::new(self.sni.destination(), &self.sni.menu().await?);
-        Ok(menu.upcast())
-    }
 }

From 25f795eb6b322de1e1832efad8f0299bb62fe5a2 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Wed, 14 Jun 2023 23:56:46 +1000
Subject: [PATCH 22/30] Reword error messages

---
 crates/notifier_host/src/item.rs | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index e5f9a682..955b9dc5 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -143,11 +143,11 @@ impl Item {
 
 #[derive(thiserror::Error, Debug)]
 pub enum IconError {
-    #[error("failed to get icon name: {0}")]
+    #[error("failed to fetch icon name: {0}")]
     DBusIconName(zbus::Error),
-    #[error("failed to get icon theme path: {0}")]
+    #[error("failed to fetch icon theme path: {0}")]
     DBusTheme(zbus::Error),
-    #[error("failed to get pixmap: {0}")]
+    #[error("failed to fetch pixmap: {0}")]
     DBusPixmap(zbus::Error),
     #[error("failed to load icon {icon_name:?} from theme {theme_path:?}")]
     LoadIconFromTheme {

From fd8bceb79332af2fa58ce14d6a9d1aee31cf1ae6 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Fri, 16 Jun 2023 16:29:53 +1000
Subject: [PATCH 23/30] Remove redundant watcher_on function

---
 crates/eww/src/widgets/systray.rs   |  5 +++-
 crates/notifier_host/src/watcher.rs | 46 ++++++++++++-----------------
 2 files changed, 23 insertions(+), 28 deletions(-)

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 3bb09407..f1cea8d6 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -21,7 +21,10 @@ async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
     } else {
         // TODO error handling?
         let con = zbus::Connection::session().await.unwrap();
-        notifier_host::watcher_on(&con).await.unwrap();
+        notifier_host::Watcher::new()
+            .attach_to(&con)
+            .await
+            .unwrap();
 
         let name = notifier_host::attach_new_wellknown_name(&con).await.unwrap();
 
diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index 256c7e35..0238faf7 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -68,6 +68,9 @@ async fn wait_for_service_exit(
     Ok(())
 }
 
+/// An instance of [`org.kde.StatusNotifierWatcher`].
+///
+/// [`org.kde.StatusNotifierWatcher`]: https://freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierWatcher/
 #[derive(Debug, Default)]
 pub struct Watcher {
     tasks: tokio::task::JoinSet<()>,
@@ -89,6 +92,7 @@ impl Watcher {
         log::info!("new host: {}", service);
 
         let added_first = {
+            // scoped around locking of hosts
             let mut hosts = self.hosts.lock().unwrap();
             if !hosts.insert(service.to_string()) {
                 // we're already tracking them
@@ -220,19 +224,25 @@ impl Watcher {
         Default::default()
     }
 
-    /// Attach the Watcher to a connection.
-    pub async fn run_on(self, con: &zbus::Connection) -> zbus::Result<()> {
+    /// Attach and run the Watcher on a connection.
+    pub async fn attach_to(self, con: &zbus::Connection) -> zbus::Result<()> {
         if !con.object_server().at(WATCHER_OBJECT_NAME, self).await? {
-            return Err(zbus::Error::Failure("Interface already exists at this path".into()))
+            // There's already something at this object
+            // TODO is there a more specific error
+            return Err(zbus::Error::Failure(format!("Connection already has an object at {}", WATCHER_OBJECT_NAME)))
         }
 
-        // no ReplaceExisting, no AllowReplacement, no DoNotQueue
-        con.request_name_with_flags(WATCHER_BUS_NAME, Default::default()).await?;
-
-        Ok(())
+        // not AllowReplacement, not ReplaceExisting, not DoNotQueue
+        let flags: [zbus::fdo::RequestNameFlags; 0] = [];
+        match con.request_name_with_flags(WATCHER_BUS_NAME, flags.into_iter().collect()).await {
+            Ok(zbus::fdo::RequestNameReply::PrimaryOwner) => Ok(()),
+            Ok(_) | Err(zbus::Error::NameTaken) => Ok(()), // defer to existing
+            Err(e) => Err(e),
+        }
     }
 
-    // Based on is_status_notifier_host_registered_invalidate, but without requiring self
+    /// Equivalent to `is_status_notifier_host_registered_invalidate`, but without requiring
+    /// `self`.
     async fn is_status_notifier_host_registered_refresh(ctxt: &zbus::SignalContext<'_>) -> zbus::Result<()> {
         zbus::fdo::Properties::properties_changed(
             ctxt,
@@ -242,7 +252,7 @@ impl Watcher {
         ).await
     }
 
-    // Based on registered_status_notifier_items_invalidate, but without requiring self
+    /// Equivalen to `registered_status_notifier_items_invalidate`, but without requiring `self`.
     async fn registered_status_notifier_items_refresh(ctxt: &zbus::SignalContext<'_>) -> zbus::Result<()> {
         zbus::fdo::Properties::properties_changed(
             ctxt,
@@ -252,21 +262,3 @@ impl Watcher {
         ).await
     }
 }
-
-/// Start a StatusNotifierWatcher on this connection.
-pub async fn watcher_on(con: &zbus::Connection) -> zbus::Result<()> {
-    if !con.object_server().at(WATCHER_OBJECT_NAME, Watcher::new()).await? {
-        // There's already something at this object
-        // TODO better handling?
-        return Err(zbus::Error::Failure(format!("Interface already exists at object {}", WATCHER_OBJECT_NAME)))
-    }
-
-    // TODO should we queue if we couldn't take the name?
-
-    use zbus::fdo::{RequestNameFlags, RequestNameReply};
-    match con.request_name_with_flags(WATCHER_BUS_NAME, [RequestNameFlags::DoNotQueue].into_iter().collect()).await {
-        Ok(RequestNameReply::PrimaryOwner) => Ok(()),
-        Ok(_) | Err(zbus::Error::NameTaken) => Ok(()), // defer to existing
-        Err(e) => Err(e),
-    }
-}

From ce3b29c6c60f5b55613851b7775c3c0855fca7c9 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Fri, 16 Jun 2023 16:30:12 +1000
Subject: [PATCH 24/30] Big icon handling refactor

---
 crates/eww/src/widgets/systray.rs |  10 +-
 crates/notifier_host/src/icon.rs  | 195 ++++++++++++++++++++++++++++++
 crates/notifier_host/src/item.rs  | 162 +------------------------
 crates/notifier_host/src/lib.rs   |   3 +
 4 files changed, 203 insertions(+), 167 deletions(-)
 create mode 100644 crates/notifier_host/src/icon.rs

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index f1cea8d6..e70dc165 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -161,10 +161,7 @@ impl Item {
             mi.set_tooltip_text(Some(&item.title().await.unwrap()));
 
             // set icon
-            match item.icon(*icon_size.borrow_and_update()).await {
-                Ok(p) => icon.set_from_pixbuf(Some(&p)),
-                Err(e) => log::warn!("failed to get icon of {}: {}", id, e),
-            }
+            icon.set_from_pixbuf(Some(&item.icon(*icon_size.borrow_and_update()).await));
 
             // updates
             let mut status_updates = item.status_updates();
@@ -181,10 +178,7 @@ impl Item {
                     }
                     Ok(_) = icon_size.changed() => {
                         // set icon
-                        match item.icon(*icon_size.borrow_and_update()).await {
-                            Ok(p) => icon.set_from_pixbuf(Some(&p)),
-                            Err(e) => log::warn!("failed to get icon of {}: {}", id, e),
-                        }
+                        icon.set_from_pixbuf(Some(&item.icon(*icon_size.borrow_and_update()).await));
                     }
                     Ok(_) = title_updates.changed() => {
                         // set title
diff --git a/crates/notifier_host/src/icon.rs b/crates/notifier_host/src/icon.rs
new file mode 100644
index 00000000..c9daa179
--- /dev/null
+++ b/crates/notifier_host/src/icon.rs
@@ -0,0 +1,195 @@
+use crate::*;
+
+use gtk::{self, prelude::*};
+
+#[derive(thiserror::Error, Debug)]
+pub enum IconError {
+    #[error("while fetching icon name: {0}")]
+    DBusIconName(#[source] zbus::Error),
+    #[error("while fetching icon theme path: {0}")]
+    DBusTheme(#[source] zbus::Error),
+    #[error("while fetching pixmap: {0}")]
+    DBusPixmap(#[source] zbus::Error),
+    #[error("loading icon from file {path:?}")]
+    LoadIconFromFile {
+        path: String,
+        #[source] source: gtk::glib::Error,
+    },
+    #[error("loading icon {icon_name:?} from theme {theme_path:?}")]
+    LoadIconFromTheme {
+        icon_name: String,
+        theme_path: Option<String>,
+        #[source] source: gtk::glib::Error,
+    },
+    #[error("no icon available")]
+    NotAvailable,
+}
+
+/// Get the fallback GTK icon
+pub async fn fallback_icon(size: i32) -> gtk::gdk_pixbuf::Pixbuf {
+    let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
+    return match theme.load_icon("image-missing", size, gtk::IconLookupFlags::FORCE_SIZE) {
+        Err(e) => {
+            log::error!("failed to load \"image-missing\" from default theme: {}", e);
+            // create a blank pixbuf
+            gtk::gdk_pixbuf::Pixbuf::new(
+                gtk::gdk_pixbuf::Colorspace::Rgb,
+                false,
+                0,
+                size,
+                size,
+            ).unwrap()
+        },
+        Ok(pb) => pb.unwrap(),
+    }
+}
+
+/// Load a pixbuf from StatusNotifierItem's [Icon format].
+///
+/// [Icon format]: https://freedesktop.org/wiki/Specifications/StatusNotifierItem/Icons/
+fn icon_from_pixmap(width: i32, height: i32, mut data: Vec<u8>) -> gtk::gdk_pixbuf::Pixbuf {
+    // We need to convert data from ARGB32 to RGBA32, since that's the only one that gdk-pixbuf
+    // understands.
+    for chunk in data.chunks_mut(4) {
+        let a = chunk[0];
+        let r = chunk[1];
+        let g = chunk[2];
+        let b = chunk[3];
+        chunk[0] = r;
+        chunk[1] = g;
+        chunk[2] = b;
+        chunk[3] = a;
+    }
+
+    gtk::gdk_pixbuf::Pixbuf::from_bytes(
+        &gtk::glib::Bytes::from_owned(data),
+        gtk::gdk_pixbuf::Colorspace::Rgb,
+        true,
+        8,
+        width,
+        height,
+        width * 4,
+    )
+}
+
+/// From a list of pixmaps, create an icon from the most appropriately sized one.
+///
+/// This function returns None if and only if no pixmaps are provided.
+fn icon_from_pixmaps(pixmaps: Vec<(i32, i32, Vec<u8>)>, size: i32) -> Option<gtk::gdk_pixbuf::Pixbuf> {
+    pixmaps.into_iter()
+        .max_by(|(w1, h1, _), (w2, h2, _)| {
+            // take smallest one bigger than requested size, otherwise take biggest
+            let a = size * size;
+            let a1 = w1 * h1;
+            let a2 = w2 * h2;
+            match (a1 >= a, a2 >= a) {
+                (true, true) => a2.cmp(&a1),
+                (true, false) => std::cmp::Ordering::Greater,
+                (false, true) => std::cmp::Ordering::Less,
+                (false, false) => a1.cmp(&a2),
+            }
+        })
+        .map(|(w, h, d)| {
+            let pixbuf = icon_from_pixmap(w, h, d);
+            if w != size || h != size {
+                pixbuf.scale_simple(size, size, gtk::gdk_pixbuf::InterpType::Bilinear).unwrap()
+            } else {
+                pixbuf
+            }
+        })
+}
+
+fn icon_from_name(icon_name: &str, theme_path: Option<&str>, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+    let theme = if let Some(path) = theme_path {
+        let theme = gtk::IconTheme::new();
+        theme.prepend_search_path(&path);
+        theme
+    } else {
+        gtk::IconTheme::default().expect("Could not get default gtk theme")
+    };
+
+    match theme.load_icon(icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
+        Ok(pb) => Ok(pb.expect("no pixbuf from theme.load_icon despite no error")),
+        Err(e) => Err(IconError::LoadIconFromTheme {
+            icon_name: icon_name.to_owned(),
+            theme_path: theme_path.map(str::to_owned),
+            source: e,
+        }),
+    }
+}
+
+pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i32) -> gtk::gdk_pixbuf::Pixbuf {
+    // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are
+    // available."
+
+    let icon_from_name: std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> = (async {
+        // fetch icon name
+        let icon_name = match sni.icon_name().await {
+            Ok(s) if s == "" => return Err(IconError::NotAvailable),
+            Ok(s) => s,
+            Err(e) => return Err(IconError::DBusIconName(e)),
+        };
+
+        // interpret it as an absolute path if we can
+        let icon_path = std::path::Path::new(&icon_name);
+        if icon_path.is_absolute() && icon_path.is_file() {
+            return gtk::gdk_pixbuf::Pixbuf::from_file_at_size(icon_path, size, size)
+                .map_err(|e| IconError::LoadIconFromFile {
+                    path: icon_name,
+                    source: e,
+                });
+        }
+
+        // otherwise, fetch icon theme and lookup using icon_from_name
+        let icon_theme_path = match sni.icon_theme_path().await {
+            Ok(p) if p == "" => None,
+            Ok(p) => Some(p),
+            // treat property not existing as the same as it being empty i.e. to use the default
+            // system theme
+            Err(zbus::Error::FDO(e)) => match *e {
+                zbus::fdo::Error::UnknownProperty(_)
+                | zbus::fdo::Error::InvalidArgs(_)
+                    => None,
+                // this error is reported by discord, blueman-applet
+                zbus::fdo::Error::Failed(msg) if msg == "error occurred in Get" => None,
+                _ => return Err(IconError::DBusTheme(zbus::Error::FDO(e))),
+            },
+            Err(e) => return Err(IconError::DBusTheme(e)),
+        };
+        let icon_theme_path: Option<&str> = match &icon_theme_path {
+            Some(s) => Some(&s),
+            None => None,
+        };
+
+        icon_from_name(&icon_name, icon_theme_path, size)
+    }).await;
+    match icon_from_name {
+        Ok(p) => return p,
+        Err(IconError::NotAvailable) => {}, // try pixbuf
+        // log and continue
+        Err(e) => log::warn!("failed to get icon by name for {}: {}", sni.destination(), e),
+    };
+
+    let icon_from_pixmaps = match sni.icon_pixmap().await {
+        Ok(ps) => match icon_from_pixmaps(ps, size) {
+            Some(p) => Ok(p),
+            None => Err(IconError::NotAvailable),
+        },
+        Err(zbus::Error::FDO(e)) => match *e {
+            // property not existing is fine
+            zbus::fdo::Error::UnknownProperty(_)
+            | zbus::fdo::Error::InvalidArgs(_)
+                => Err(IconError::NotAvailable),
+
+            _ => Err(IconError::DBusPixmap(zbus::Error::FDO(e))),
+        },
+        Err(e) => Err(IconError::DBusPixmap(e)),
+    };
+    match icon_from_pixmaps {
+        Ok(p) => return p,
+        Err(IconError::NotAvailable) => {},
+        Err(e) => log::warn!("failed to get icon pixmap for {}: {}", sni.destination(), e),
+    };
+
+    fallback_icon(size).await
+}
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index 955b9dc5..57802fea 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -1,6 +1,5 @@
 use crate::*;
 
-use log;
 use gtk::{self, prelude::*};
 use zbus::export::ordered_stream::OrderedStreamExt;
 use tokio::{sync::watch, select};
@@ -139,164 +138,9 @@ impl Item {
         let menu = dbusmenu_gtk3::Menu::new(self.sni.destination(), &self.sni.menu().await?);
         Ok(menu.upcast())
     }
-}
-
-#[derive(thiserror::Error, Debug)]
-pub enum IconError {
-    #[error("failed to fetch icon name: {0}")]
-    DBusIconName(zbus::Error),
-    #[error("failed to fetch icon theme path: {0}")]
-    DBusTheme(zbus::Error),
-    #[error("failed to fetch pixmap: {0}")]
-    DBusPixmap(zbus::Error),
-    #[error("failed to load icon {icon_name:?} from theme {theme_path:?}")]
-    LoadIconFromTheme {
-        icon_name: String,
-        theme_path: Option<String>,
-        source: gtk::glib::Error,
-    },
-    #[error("no icon available")]
-    NotAvailable,
-}
-
-/// Get the fallback GTK icon
-async fn fallback_icon(size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-    // TODO downgrade from panic to error return?
-    let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
-    return match theme.load_icon("image-missing", size, gtk::IconLookupFlags::FORCE_SIZE) {
-        Err(e) => Err(IconError::LoadIconFromTheme {
-            icon_name: "image-missing".to_owned(),
-            theme_path: None,
-            source: e,
-        }),
-        Ok(pb) => Ok(pb.unwrap()),
-    }
-}
-
-impl Item {
-    pub fn load_pixbuf(width: i32, height: i32, mut data: Vec<u8>) -> gtk::gdk_pixbuf::Pixbuf {
-        // We need to convert data from ARGB32 to RGBA32
-        for chunk in data.chunks_mut(4) {
-            let a = chunk[0];
-            let r = chunk[1];
-            let g = chunk[2];
-            let b = chunk[3];
-            chunk[0] = r;
-            chunk[1] = g;
-            chunk[2] = b;
-            chunk[3] = a;
-        }
-
-        gtk::gdk_pixbuf::Pixbuf::from_bytes(
-            &gtk::glib::Bytes::from_owned(data),
-            gtk::gdk_pixbuf::Colorspace::Rgb,
-            true,
-            8,
-            width,
-            height,
-            width * 4,
-        )
-    }
-
-    async fn icon_from_name(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-        // TODO better handling of icon_name failure instead of punting it to the caller
-        let icon_name = match self.sni.icon_name().await {
-            Ok(s) if s == "" => return Err(IconError::NotAvailable),
-            Ok(s) => s,
-            Err(e) => return Err(IconError::DBusIconName(e)),
-        };
-
-        let icon_theme_path = match self.sni.icon_theme_path().await {
-            Ok(p) if p == "" => None,
-            Ok(p) => Some(p),
-            Err(zbus::Error::FDO(e)) => match *e {
-                zbus::fdo::Error::UnknownProperty(_)
-                | zbus::fdo::Error::InvalidArgs(_)
-                    => None,
-                // this error is reported by discord, blueman-applet
-                zbus::fdo::Error::Failed(msg) if msg == "error occurred in Get" => None,
-                _ => return Err(IconError::DBusTheme(zbus::Error::FDO(e))),
-            },
-            Err(e) => return Err(IconError::DBusTheme(e)),
-        };
-
-        if let Some(theme_path) = icon_theme_path {
-            // icon supplied a theme path, so only look there (w/ fallback)
-            let theme = gtk::IconTheme::new();
-            theme.prepend_search_path(&theme_path);
-
-            return match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
-                Err(e) => Err(IconError::LoadIconFromTheme {
-                    icon_name,
-                    theme_path: Some(theme_path),
-                    source: e,
-                }),
-                Ok(pb) => return Ok(pb.expect("no pixbuf from theme.load_icon despite no error")),
-            }
-        }
-
-        // fallback to default theme
-        let theme = gtk::IconTheme::default().expect("Could not get default gtk theme");
-        match theme.load_icon(&icon_name, size, gtk::IconLookupFlags::FORCE_SIZE) {
-            // TODO specifically match on icon missing here
-            Err(e) => {
-                log::warn!("Could not find icon {:?} in default theme: {}", &icon_name, e);
-                Err(IconError::LoadIconFromTheme {
-                    icon_name,
-                    theme_path: None,
-                    source: e,
-                })
-            },
-            Ok(pb) => Ok(pb.unwrap()),
-        }
-    }
-
-    async fn icon_from_pixmap(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-        match self.sni.icon_pixmap().await {
-            Ok(ps) => {
-                for (width, height, data) in ps {
-                    // TODO use closest size instead of looking for exact match
-                    // (can be tested with keepassxc, which only provides 48x48 and 22x22 pixmaps)
-                    if width == size && height == size {
-                        return Ok(Self::load_pixbuf(width, height, data))
-                    }
-                }
-
-                Err(IconError::NotAvailable)
-            },
-            Err(zbus::Error::FDO(e)) => match *e {
-                zbus::fdo::Error::UnknownProperty(_)
-                | zbus::fdo::Error::InvalidArgs(_)
-                    => Err(IconError::NotAvailable),
-                _ => Err(IconError::DBusPixmap(zbus::Error::FDO(e))),
-            },
-            Err(e) => Err(IconError::DBusPixmap(e)),
-        }
-    }
-
-    pub async fn icon(&self, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
-        // TODO make this function retun just Pixbuf instead of a result, now that we're handling
-        // all errors here?
-
-        // "Visualizations are encouraged to prefer icon names over icon pixmaps if both are
-        // available."
-
-        match self.icon_from_name(size).await {
-            Ok(pb) => return Ok(pb),
-            Err(IconError::NotAvailable)
-            | Err(IconError::LoadIconFromTheme { .. })
-                => {},
-            // Don't fail icon loading here -- e.g. discord raises
-            // "org.freedesktop.DBus.Error.Failed: error occurred in Get" but has a valid pixmap
-            Err(e) => log::warn!("failed to get icon by name for {}: {}", self.sni.destination(), e),
-        }
-
-        match self.icon_from_pixmap(size).await {
-            Ok(pb) => return Ok(pb),
-            Err(IconError::NotAvailable) => {},
-            Err(e) => log::warn!("failed to get icon pixmap for {}: {}", self.sni.destination(), e),
-        }
 
-        fallback_icon(size).await
+    pub async fn icon(&self, size: i32) -> gtk::gdk_pixbuf::Pixbuf {
+        // see icon.rs
+        load_icon_from_sni(&self.sni, size).await
     }
 }
diff --git a/crates/notifier_host/src/lib.rs b/crates/notifier_host/src/lib.rs
index 3ccc94b3..b4676e24 100644
--- a/crates/notifier_host/src/lib.rs
+++ b/crates/notifier_host/src/lib.rs
@@ -3,6 +3,9 @@ pub mod dbus;
 mod host;
 pub use host::*;
 
+mod icon;
+pub use icon::*;
+
 mod item;
 pub use item::*;
 

From 3a8a83c39fff1be7e904ac052cf3ea8e8ba897a9 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Fri, 16 Jun 2023 17:12:17 +1000
Subject: [PATCH 25/30] Don't unnecessarily wrap StatusNotifierItem

---
 crates/eww/src/widgets/systray.rs | 13 ++++----
 crates/notifier_host/src/item.rs  | 50 +------------------------------
 crates/notifier_host/src/lib.rs   |  4 +++
 3 files changed, 12 insertions(+), 55 deletions(-)

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index e70dc165..596b2e98 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -2,6 +2,7 @@
 
 use gtk::prelude::*;
 use notifier_host;
+use notifier_host::export::ordered_stream::OrderedStreamExt;
 
 // DBus state shared between systray instances, to avoid creating too many connections etc.
 struct DBusGlobalState {
@@ -158,18 +159,18 @@ impl Item {
             }
 
             // set title
-            mi.set_tooltip_text(Some(&item.title().await.unwrap()));
+            mi.set_tooltip_text(Some(&item.sni.title().await.unwrap()));
 
             // set icon
             icon.set_from_pixbuf(Some(&item.icon(*icon_size.borrow_and_update()).await));
 
             // updates
-            let mut status_updates = item.status_updates();
-            let mut title_updates = item.title_updates();
+            let mut status_updates = item.sni.receive_new_status().await.unwrap();
+            let mut title_updates = item.sni.receive_new_status().await.unwrap();
 
             loop {
                 tokio::select! {
-                    Ok(_) = status_updates.changed() => {
+                    Some(_) = status_updates.next() => {
                         // set status
                         match item.status().await.unwrap() {
                             notifier_host::Status::Passive => mi.hide(),
@@ -180,9 +181,9 @@ impl Item {
                         // set icon
                         icon.set_from_pixbuf(Some(&item.icon(*icon_size.borrow_and_update()).await));
                     }
-                    Ok(_) = title_updates.changed() => {
+                    Some(_) = title_updates.next() => {
                         // set title
-                        mi.set_tooltip_text(Some(&item.title().await.unwrap()));
+                        mi.set_tooltip_text(Some(&item.sni.title().await.unwrap()));
                     }
                 }
             }
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index 57802fea..2c2f8eec 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -1,8 +1,6 @@
 use crate::*;
 
 use gtk::{self, prelude::*};
-use zbus::export::ordered_stream::OrderedStreamExt;
-use tokio::{sync::watch, select};
 
 /// Recognised values of org.freedesktop.StatusNotifierItem.Status
 ///
@@ -62,17 +60,6 @@ fn split_service_name(service: &str) -> zbus::Result<(String, String)> {
 
 pub struct Item {
     pub sni: dbus::StatusNotifierItemProxy<'static>,
-
-    status_rx: watch::Receiver<()>,
-    title_rx: watch::Receiver<()>,
-
-    task: tokio::task::JoinHandle<()>,
-}
-
-impl Drop for Item {
-    fn drop(&mut self) {
-        self.task.abort();
-    }
 }
 
 impl Item {
@@ -83,32 +70,9 @@ impl Item {
             .path(path)?
             .build()
             .await?;
-        let sni_out = sni.clone();
-
-        let (status_tx, status_rx) = watch::channel(());
-        let (title_tx, title_rx) = watch::channel(());
-
-        let task = tokio::spawn(async move {
-            let mut status_updates = sni.receive_new_status().await.unwrap();
-            let mut title_updates = sni.receive_new_title().await.unwrap();
-
-            loop {
-                select! {
-                    _ = status_updates.next() => {
-                        status_tx.send_replace(());
-                    }
-                    _ = title_updates.next() => {
-                        title_tx.send_replace(());
-                    }
-                }
-            }
-        });
 
         Ok(Item {
-            sni: sni_out,
-            status_rx,
-            title_rx,
-            task,
+            sni,
         })
     }
 
@@ -121,18 +85,6 @@ impl Item {
         }
     }
 
-    pub fn status_updates(&self) -> watch::Receiver<()> {
-        self.status_rx.clone()
-    }
-
-    pub async fn title(&self) -> zbus::Result<String> {
-        self.sni.title().await
-    }
-
-    pub fn title_updates(&self) -> watch::Receiver<()> {
-        self.title_rx.clone()
-    }
-
     pub async fn menu(&self) -> zbus::Result<gtk::Menu> {
         // TODO better handling if menu() method doesn't exist
         let menu = dbusmenu_gtk3::Menu::new(self.sni.destination(), &self.sni.menu().await?);
diff --git a/crates/notifier_host/src/lib.rs b/crates/notifier_host/src/lib.rs
index b4676e24..a5fe2dd6 100644
--- a/crates/notifier_host/src/lib.rs
+++ b/crates/notifier_host/src/lib.rs
@@ -11,3 +11,7 @@ pub use item::*;
 
 mod watcher;
 pub use watcher::*;
+
+pub mod export {
+    pub use zbus::export::ordered_stream;
+}

From eac2b932463cb621921b336899e87a606e904cee Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Fri, 16 Jun 2023 17:25:56 +1000
Subject: [PATCH 26/30] cargo fmt

---
 crates/eww/src/widgets/systray.rs             | 50 +++++--------------
 .../src/dbus/dbus_status_notifier_watcher.rs  |  6 +--
 crates/notifier_host/src/host.rs              | 22 ++++----
 crates/notifier_host/src/icon.rs              | 47 ++++++++---------
 crates/notifier_host/src/item.rs              | 13 ++---
 crates/notifier_host/src/watcher.rs           | 36 ++++++-------
 6 files changed, 68 insertions(+), 106 deletions(-)

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 596b2e98..511127dc 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -1,8 +1,7 @@
 #![allow(unused)]
 
 use gtk::prelude::*;
-use notifier_host;
-use notifier_host::export::ordered_stream::OrderedStreamExt;
+use notifier_host::{self, export::ordered_stream::OrderedStreamExt};
 
 // DBus state shared between systray instances, to avoid creating too many connections etc.
 struct DBusGlobalState {
@@ -11,9 +10,9 @@ struct DBusGlobalState {
 }
 
 async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
-    use tokio::sync::Mutex;
-    use std::sync::{Weak, Arc};
     use once_cell::sync::Lazy;
+    use std::sync::{Arc, Weak};
+    use tokio::sync::Mutex;
     static DBUS_STATE: Lazy<Mutex<Weak<DBusGlobalState>>> = Lazy::new(Default::default);
 
     let mut dbus_state = DBUS_STATE.lock().await;
@@ -22,17 +21,11 @@ async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
     } else {
         // TODO error handling?
         let con = zbus::Connection::session().await.unwrap();
-        notifier_host::Watcher::new()
-            .attach_to(&con)
-            .await
-            .unwrap();
+        notifier_host::Watcher::new().attach_to(&con).await.unwrap();
 
         let name = notifier_host::attach_new_wellknown_name(&con).await.unwrap();
 
-        let arc = Arc::new(DBusGlobalState {
-            con,
-            name,
-        });
+        let arc = Arc::new(DBusGlobalState { con, name });
         *dbus_state = Arc::downgrade(&arc);
 
         arc
@@ -46,9 +39,7 @@ pub struct Props {
 impl Props {
     pub fn new() -> Self {
         let (icon_size_tx, _) = tokio::sync::watch::channel(24);
-        Self {
-            icon_size_tx,
-        }
+        Self { icon_size_tx }
     }
 
     pub fn icon_size(&self, value: i32) {
@@ -70,15 +61,8 @@ struct Tray {
     icon_size: tokio::sync::watch::Receiver<i32>,
 }
 
-pub fn spawn_systray(
-    menubar: &gtk::MenuBar,
-    props: &Props,
-) {
-    let mut systray = Tray {
-        menubar: menubar.clone(),
-        items: Default::default(),
-        icon_size: props.icon_size_tx.subscribe(),
-    };
+pub fn spawn_systray(menubar: &gtk::MenuBar, props: &Props) {
+    let mut systray = Tray { menubar: menubar.clone(), items: Default::default(), icon_size: props.icon_size_tx.subscribe() };
 
     glib::MainContext::default().spawn_local(async move {
         let s = &dbus_state().await;
@@ -89,16 +73,13 @@ pub fn spawn_systray(
 
 impl notifier_host::Host for Tray {
     fn add_item(&mut self, id: &str, item: notifier_host::Item) {
-        let item = Item::new(
-            id.to_owned(),
-            item,
-            self.icon_size.clone()
-        );
+        let item = Item::new(id.to_owned(), item, self.icon_size.clone());
         self.menubar.add(&item.mi);
         if let Some(old_item) = self.items.insert(id.to_string(), item) {
             self.menubar.remove(&old_item.mi);
         }
     }
+
     fn remove_item(&mut self, id: &str) {
         if let Some(item) = self.items.get(id) {
             self.menubar.remove(&item.mi);
@@ -124,16 +105,9 @@ impl Drop for Item {
 }
 
 impl Item {
-    fn new(
-        id: String,
-        item: notifier_host::Item,
-        mut icon_size: tokio::sync::watch::Receiver<i32>,
-    ) -> Self {
+    fn new(id: String, item: notifier_host::Item, mut icon_size: tokio::sync::watch::Receiver<i32>) -> Self {
         let mi = gtk::MenuItem::new();
-        let mut out = Self {
-            mi: mi.clone(),
-            tasks: Vec::new(),
-        };
+        let mut out = Self { mi: mi.clone(), tasks: Vec::new() };
 
         out.spawn(async move {
             // TODO don't unwrap so much
diff --git a/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs b/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs
index 8c352793..9ac2eaa9 100644
--- a/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs
+++ b/crates/notifier_host/src/dbus/dbus_status_notifier_watcher.rs
@@ -12,9 +12,9 @@
 use zbus::dbus_proxy;
 
 #[dbus_proxy(
-    default_service="org.kde.StatusNotifierWatcher",
-    interface="org.kde.StatusNotifierWatcher",
-    default_path="/StatusNotifierWatcher",
+    default_service = "org.kde.StatusNotifierWatcher",
+    interface = "org.kde.StatusNotifierWatcher",
+    default_path = "/StatusNotifierWatcher"
 )]
 trait StatusNotifierWatcher {
     /// RegisterStatusNotifierHost method
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index e16eb2e2..b20b2d79 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -21,15 +21,19 @@ pub async fn attach_new_wellknown_name(con: &zbus::Connection) -> zbus::Result<z
         let flags = [zbus::fdo::RequestNameFlags::DoNotQueue];
         match con.request_name_with_flags(&wellknown, flags.into_iter().collect()).await? {
             PrimaryOwner => break wellknown,
-            Exists => {},
-            AlreadyOwner => {},
+            Exists => {}
+            AlreadyOwner => {}
             InQueue => unreachable!("request_name_with_flags returned InQueue even though we specified DoNotQueue"),
         };
     };
     Ok(wellknown)
 }
 
-pub async fn run_host_forever(host: &mut dyn Host, con: &zbus::Connection, name: &zbus::names::WellKnownName<'_>) -> zbus::Result<()> {
+pub async fn run_host_forever(
+    host: &mut dyn Host,
+    con: &zbus::Connection,
+    name: &zbus::names::WellKnownName<'_>,
+) -> zbus::Result<()> {
     // register ourself to StatusNotifierWatcher
     let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;
     snw.register_status_notifier_host(&name).await?;
@@ -51,10 +55,10 @@ pub async fn run_host_forever(host: &mut dyn Host, con: &zbus::Connection, name:
             Ok(item) => {
                 item_names.insert(svc.to_owned());
                 host.add_item(&svc, item);
-            },
+            }
             Err(e) => {
                 log::warn!("Could not create StatusNotifierItem from address {:?}: {:?}", svc, e);
-            },
+            }
         }
     }
 
@@ -73,19 +77,19 @@ pub async fn run_host_forever(host: &mut dyn Host, con: &zbus::Connection, name:
                         Ok(item) => {
                             item_names.insert(svc.to_owned());
                             host.add_item(svc, item);
-                        },
+                        }
                         Err(e) => {
                             log::warn!("Could not create StatusNotifierItem from address {:?}: {:?}", svc, e);
-                        },
+                        }
                     }
                 }
-            },
+            }
             ItemEvent::GoneItem(sig) => {
                 let svc = sig.args()?.service;
                 if item_names.remove(svc) {
                     host.remove_item(svc);
                 }
-            },
+            }
         }
     }
 
diff --git a/crates/notifier_host/src/icon.rs b/crates/notifier_host/src/icon.rs
index c9daa179..137a165f 100644
--- a/crates/notifier_host/src/icon.rs
+++ b/crates/notifier_host/src/icon.rs
@@ -13,13 +13,15 @@ pub enum IconError {
     #[error("loading icon from file {path:?}")]
     LoadIconFromFile {
         path: String,
-        #[source] source: gtk::glib::Error,
+        #[source]
+        source: gtk::glib::Error,
     },
     #[error("loading icon {icon_name:?} from theme {theme_path:?}")]
     LoadIconFromTheme {
         icon_name: String,
         theme_path: Option<String>,
-        #[source] source: gtk::glib::Error,
+        #[source]
+        source: gtk::glib::Error,
     },
     #[error("no icon available")]
     NotAvailable,
@@ -32,16 +34,10 @@ pub async fn fallback_icon(size: i32) -> gtk::gdk_pixbuf::Pixbuf {
         Err(e) => {
             log::error!("failed to load \"image-missing\" from default theme: {}", e);
             // create a blank pixbuf
-            gtk::gdk_pixbuf::Pixbuf::new(
-                gtk::gdk_pixbuf::Colorspace::Rgb,
-                false,
-                0,
-                size,
-                size,
-            ).unwrap()
-        },
+            gtk::gdk_pixbuf::Pixbuf::new(gtk::gdk_pixbuf::Colorspace::Rgb, false, 0, size, size).unwrap()
+        }
         Ok(pb) => pb.unwrap(),
-    }
+    };
 }
 
 /// Load a pixbuf from StatusNotifierItem's [Icon format].
@@ -76,7 +72,8 @@ fn icon_from_pixmap(width: i32, height: i32, mut data: Vec<u8>) -> gtk::gdk_pixb
 ///
 /// This function returns None if and only if no pixmaps are provided.
 fn icon_from_pixmaps(pixmaps: Vec<(i32, i32, Vec<u8>)>, size: i32) -> Option<gtk::gdk_pixbuf::Pixbuf> {
-    pixmaps.into_iter()
+    pixmaps
+        .into_iter()
         .max_by(|(w1, h1, _), (w2, h2, _)| {
             // take smallest one bigger than requested size, otherwise take biggest
             let a = size * size;
@@ -99,7 +96,11 @@ fn icon_from_pixmaps(pixmaps: Vec<(i32, i32, Vec<u8>)>, size: i32) -> Option<gtk
         })
 }
 
-fn icon_from_name(icon_name: &str, theme_path: Option<&str>, size: i32) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
+fn icon_from_name(
+    icon_name: &str,
+    theme_path: Option<&str>,
+    size: i32,
+) -> std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> {
     let theme = if let Some(path) = theme_path {
         let theme = gtk::IconTheme::new();
         theme.prepend_search_path(&path);
@@ -134,10 +135,7 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
         let icon_path = std::path::Path::new(&icon_name);
         if icon_path.is_absolute() && icon_path.is_file() {
             return gtk::gdk_pixbuf::Pixbuf::from_file_at_size(icon_path, size, size)
-                .map_err(|e| IconError::LoadIconFromFile {
-                    path: icon_name,
-                    source: e,
-                });
+                .map_err(|e| IconError::LoadIconFromFile { path: icon_name, source: e });
         }
 
         // otherwise, fetch icon theme and lookup using icon_from_name
@@ -147,9 +145,7 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
             // treat property not existing as the same as it being empty i.e. to use the default
             // system theme
             Err(zbus::Error::FDO(e)) => match *e {
-                zbus::fdo::Error::UnknownProperty(_)
-                | zbus::fdo::Error::InvalidArgs(_)
-                    => None,
+                zbus::fdo::Error::UnknownProperty(_) | zbus::fdo::Error::InvalidArgs(_) => None,
                 // this error is reported by discord, blueman-applet
                 zbus::fdo::Error::Failed(msg) if msg == "error occurred in Get" => None,
                 _ => return Err(IconError::DBusTheme(zbus::Error::FDO(e))),
@@ -162,10 +158,11 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
         };
 
         icon_from_name(&icon_name, icon_theme_path, size)
-    }).await;
+    })
+    .await;
     match icon_from_name {
         Ok(p) => return p,
-        Err(IconError::NotAvailable) => {}, // try pixbuf
+        Err(IconError::NotAvailable) => {} // try pixbuf
         // log and continue
         Err(e) => log::warn!("failed to get icon by name for {}: {}", sni.destination(), e),
     };
@@ -177,9 +174,7 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
         },
         Err(zbus::Error::FDO(e)) => match *e {
             // property not existing is fine
-            zbus::fdo::Error::UnknownProperty(_)
-            | zbus::fdo::Error::InvalidArgs(_)
-                => Err(IconError::NotAvailable),
+            zbus::fdo::Error::UnknownProperty(_) | zbus::fdo::Error::InvalidArgs(_) => Err(IconError::NotAvailable),
 
             _ => Err(IconError::DBusPixmap(zbus::Error::FDO(e))),
         },
@@ -187,7 +182,7 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
     };
     match icon_from_pixmaps {
         Ok(p) => return p,
-        Err(IconError::NotAvailable) => {},
+        Err(IconError::NotAvailable) => {}
         Err(e) => log::warn!("failed to get icon pixmap for {}: {}", sni.destination(), e),
     };
 
diff --git a/crates/notifier_host/src/item.rs b/crates/notifier_host/src/item.rs
index 2c2f8eec..4ab2f090 100644
--- a/crates/notifier_host/src/item.rs
+++ b/crates/notifier_host/src/item.rs
@@ -44,7 +44,8 @@ impl std::str::FromStr for Status {
 fn split_service_name(service: &str) -> zbus::Result<(String, String)> {
     if let Some((addr, path)) = service.split_once('/') {
         Ok((addr.to_owned(), format!("/{}", path)))
-    } else if service.contains(':') { // TODO why?
+    } else if service.contains(':') {
+        // TODO why?
         let addr = service.split(':').skip(1).next();
         // Some StatusNotifierItems will not return an object path, in that case we fallback
         // to the default path.
@@ -65,15 +66,9 @@ pub struct Item {
 impl Item {
     pub async fn from_address(con: &zbus::Connection, addr: &str) -> zbus::Result<Self> {
         let (addr, path) = split_service_name(addr)?;
-        let sni = dbus::StatusNotifierItemProxy::builder(con)
-            .destination(addr)?
-            .path(path)?
-            .build()
-            .await?;
+        let sni = dbus::StatusNotifierItemProxy::builder(con).destination(addr)?.path(path)?.build().await?;
 
-        Ok(Item {
-            sni,
-        })
+        Ok(Item { sni })
     }
 
     /// Get the current status of the item.
diff --git a/crates/notifier_host/src/watcher.rs b/crates/notifier_host/src/watcher.rs
index 0238faf7..d04bf194 100644
--- a/crates/notifier_host/src/watcher.rs
+++ b/crates/notifier_host/src/watcher.rs
@@ -1,6 +1,4 @@
-use zbus::dbus_interface;
-use zbus::Interface;
-use zbus::export::ordered_stream::OrderedStreamExt;
+use zbus::{dbus_interface, export::ordered_stream::OrderedStreamExt, Interface};
 
 pub const WATCHER_BUS_NAME: &'static str = "org.kde.StatusNotifierWatcher";
 pub const WATCHER_OBJECT_NAME: &'static str = "/StatusNotifierWatcher";
@@ -9,8 +7,7 @@ async fn parse_service<'a>(
     service: &'a str,
     hdr: zbus::MessageHeader<'_>,
     con: &zbus::Connection,
-) -> zbus::fdo::Result<(zbus::names::UniqueName<'static>, &'a str)>
-{
+) -> zbus::fdo::Result<(zbus::names::UniqueName<'static>, &'a str)> {
     if service.starts_with("/") {
         // they sent us just the object path :(
         if let Some(sender) = hdr.sender()? {
@@ -25,7 +22,7 @@ async fn parse_service<'a>(
             Err(e) => {
                 log::warn!("received invalid bus name {:?}: {}", service, e);
                 return Err(zbus::fdo::Error::InvalidArgs(e.to_string()));
-            },
+            }
         };
 
         if let zbus::names::BusName::Unique(unique) = busname {
@@ -45,23 +42,18 @@ async fn parse_service<'a>(
 }
 
 /// Wait for a DBus service to exit
-async fn wait_for_service_exit(
-    connection: zbus::Connection,
-    service: zbus::names::BusName<'_>,
-) -> zbus::fdo::Result<()> {
+async fn wait_for_service_exit(connection: zbus::Connection, service: zbus::names::BusName<'_>) -> zbus::fdo::Result<()> {
     let dbus = zbus::fdo::DBusProxy::new(&connection).await?;
-    let mut owner_changes = dbus
-        .receive_name_owner_changed_with_args(&[(0, &service)])
-        .await?;
+    let mut owner_changes = dbus.receive_name_owner_changed_with_args(&[(0, &service)]).await?;
 
     if !dbus.name_has_owner(service.as_ref()).await? {
-        return Ok(())
+        return Ok(());
     }
 
     while let Some(sig) = owner_changes.next().await {
         let args = sig.args()?;
         if args.new_owner().is_none() {
-            break
+            break;
         }
     }
 
@@ -78,7 +70,7 @@ pub struct Watcher {
     items: std::sync::Arc<std::sync::Mutex<std::collections::HashSet<String>>>,
 }
 
-#[dbus_interface(name="org.kde.StatusNotifierWatcher")]
+#[dbus_interface(name = "org.kde.StatusNotifierWatcher")]
 impl Watcher {
     /// RegisterStatusNotifierHost method
     async fn register_status_notifier_host(
@@ -96,7 +88,7 @@ impl Watcher {
             let mut hosts = self.hosts.lock().unwrap();
             if !hosts.insert(service.to_string()) {
                 // we're already tracking them
-                return Ok(())
+                return Ok(());
             }
             hosts.len() == 1
         };
@@ -165,7 +157,7 @@ impl Watcher {
             if !items.insert(item.clone()) {
                 // we're already tracking them
                 log::info!("new item: {} (duplicate)", item);
-                return Ok(())
+                return Ok(());
             }
         }
         log::info!("new item: {}", item);
@@ -229,7 +221,7 @@ impl Watcher {
         if !con.object_server().at(WATCHER_OBJECT_NAME, self).await? {
             // There's already something at this object
             // TODO is there a more specific error
-            return Err(zbus::Error::Failure(format!("Connection already has an object at {}", WATCHER_OBJECT_NAME)))
+            return Err(zbus::Error::Failure(format!("Connection already has an object at {}", WATCHER_OBJECT_NAME)));
         }
 
         // not AllowReplacement, not ReplaceExisting, not DoNotQueue
@@ -249,7 +241,8 @@ impl Watcher {
             Self::name(),
             &std::collections::HashMap::new(),
             &["IsStatusNotifierHostRegistered"],
-        ).await
+        )
+        .await
     }
 
     /// Equivalen to `registered_status_notifier_items_invalidate`, but without requiring `self`.
@@ -259,6 +252,7 @@ impl Watcher {
             Self::name(),
             &std::collections::HashMap::new(),
             &["RegisteredStatusNotifierItems"],
-        ).await
+        )
+        .await
     }
 }

From 5f69d75f75e47597d4ccb4d0fb1d0fc4f1440370 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Fri, 16 Jun 2023 17:31:25 +1000
Subject: [PATCH 27/30] Documentation

---
 CHANGELOG.md                                 | 1 +
 crates/eww/src/widgets/widget_definitions.rs | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8f3bbcb0..b90c9180 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,6 +17,7 @@ All notable changes to eww will be listed here, starting at changes since versio
 - Add `jq` function, offering jq-style json processing
 - Add `justify` property to the label widget, allowing text justification (By: n3oney)
 - Add `EWW_TIME` magic variable (By: Erenoit)
+- Add `systray` widget (By: ralismark)
 
 ## [0.4.0] (04.09.2022)
 
diff --git a/crates/eww/src/widgets/widget_definitions.rs b/crates/eww/src/widgets/widget_definitions.rs
index 21d145bd..bd33b2af 100644
--- a/crates/eww/src/widgets/widget_definitions.rs
+++ b/crates/eww/src/widgets/widget_definitions.rs
@@ -1118,7 +1118,7 @@ fn parse_justification(j: &str) -> Result<gtk::Justification> {
     }
 }
 
-/// @var packdirection - "right", "ltr", "left", "rtl", "down", "ttb", "up", "btt"
+/// @var pack-direction - "right", "ltr", "left", "rtl", "down", "ttb", "up", "btt"
 fn parse_packdirection(o: &str) -> Result<gtk::PackDirection> {
     enum_parse! { "packdirection", o,
         "right" | "ltr" => gtk::PackDirection::Ltr,

From 78750d0bd14a1485317c49d499cc928339e38aa6 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Sun, 18 Jun 2023 21:51:16 +1000
Subject: [PATCH 28/30] Avoid registering to StatusNotifierWatcher multiple
 times

---
 crates/eww/src/widgets/systray.rs |  7 +++++--
 crates/notifier_host/src/host.rs  | 11 ++++++++---
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/crates/eww/src/widgets/systray.rs b/crates/eww/src/widgets/systray.rs
index 511127dc..3804d2c7 100644
--- a/crates/eww/src/widgets/systray.rs
+++ b/crates/eww/src/widgets/systray.rs
@@ -7,6 +7,7 @@ use notifier_host::{self, export::ordered_stream::OrderedStreamExt};
 struct DBusGlobalState {
     con: zbus::Connection,
     name: zbus::names::WellKnownName<'static>,
+    snw: notifier_host::dbus::StatusNotifierWatcherProxy<'static>,
 }
 
 async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
@@ -24,8 +25,9 @@ async fn dbus_state() -> std::sync::Arc<DBusGlobalState> {
         notifier_host::Watcher::new().attach_to(&con).await.unwrap();
 
         let name = notifier_host::attach_new_wellknown_name(&con).await.unwrap();
+        let snw = notifier_host::register_to_watcher(&con, &name).await.unwrap();
 
-        let arc = Arc::new(DBusGlobalState { con, name });
+        let arc = Arc::new(DBusGlobalState { con, name, snw });
         *dbus_state = Arc::downgrade(&arc);
 
         arc
@@ -64,10 +66,11 @@ struct Tray {
 pub fn spawn_systray(menubar: &gtk::MenuBar, props: &Props) {
     let mut systray = Tray { menubar: menubar.clone(), items: Default::default(), icon_size: props.icon_size_tx.subscribe() };
 
+    // TODO when does this task die?
     glib::MainContext::default().spawn_local(async move {
         let s = &dbus_state().await;
         systray.menubar.show();
-        notifier_host::run_host_forever(&mut systray, &s.con, &s.name).await.unwrap();
+        notifier_host::run_host_forever(&mut systray, &s.snw).await.unwrap();
     });
 }
 
diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index b20b2d79..5278363c 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -29,15 +29,20 @@ pub async fn attach_new_wellknown_name(con: &zbus::Connection) -> zbus::Result<z
     Ok(wellknown)
 }
 
-pub async fn run_host_forever(
-    host: &mut dyn Host,
+pub async fn register_to_watcher(
     con: &zbus::Connection,
     name: &zbus::names::WellKnownName<'_>,
-) -> zbus::Result<()> {
+) -> zbus::Result<dbus::StatusNotifierWatcherProxy<'static>> {
     // register ourself to StatusNotifierWatcher
     let snw = dbus::StatusNotifierWatcherProxy::new(&con).await?;
     snw.register_status_notifier_host(&name).await?;
+    Ok(snw)
+}
 
+pub async fn run_host_forever(
+    host: &mut dyn Host,
+    snw: &dbus::StatusNotifierWatcherProxy<'static>,
+) -> zbus::Result<()> {
     enum ItemEvent {
         NewItem(dbus::StatusNotifierItemRegistered),
         GoneItem(dbus::StatusNotifierItemUnregistered),

From b41467efabd4685d081a716e015995b6990e0f6c Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Thu, 22 Jun 2023 13:24:35 +1000
Subject: [PATCH 29/30] None theme means default theme

---
 crates/notifier_host/src/host.rs | 5 +----
 crates/notifier_host/src/icon.rs | 2 +-
 2 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/crates/notifier_host/src/host.rs b/crates/notifier_host/src/host.rs
index 5278363c..c8948e68 100644
--- a/crates/notifier_host/src/host.rs
+++ b/crates/notifier_host/src/host.rs
@@ -39,10 +39,7 @@ pub async fn register_to_watcher(
     Ok(snw)
 }
 
-pub async fn run_host_forever(
-    host: &mut dyn Host,
-    snw: &dbus::StatusNotifierWatcherProxy<'static>,
-) -> zbus::Result<()> {
+pub async fn run_host_forever(host: &mut dyn Host, snw: &dbus::StatusNotifierWatcherProxy<'static>) -> zbus::Result<()> {
     enum ItemEvent {
         NewItem(dbus::StatusNotifierItemRegistered),
         GoneItem(dbus::StatusNotifierItemUnregistered),
diff --git a/crates/notifier_host/src/icon.rs b/crates/notifier_host/src/icon.rs
index 137a165f..c8bb8faf 100644
--- a/crates/notifier_host/src/icon.rs
+++ b/crates/notifier_host/src/icon.rs
@@ -16,7 +16,7 @@ pub enum IconError {
         #[source]
         source: gtk::glib::Error,
     },
-    #[error("loading icon {icon_name:?} from theme {theme_path:?}")]
+    #[error("loading icon {icon_name:?} from theme {}", .theme_path.as_ref().unwrap_or(&"(default)".to_owned()))]
     LoadIconFromTheme {
         icon_name: String,
         theme_path: Option<String>,

From be553cb56f771e230aec5b9aff61f218c52d37d8 Mon Sep 17 00:00:00 2001
From: ralismark <13449732+ralismark@users.noreply.github.com>
Date: Thu, 22 Jun 2023 22:47:26 +1000
Subject: [PATCH 30/30] Add dbus logging

---
 crates/notifier_host/src/icon.rs | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/crates/notifier_host/src/icon.rs b/crates/notifier_host/src/icon.rs
index c8bb8faf..2ca7408a 100644
--- a/crates/notifier_host/src/icon.rs
+++ b/crates/notifier_host/src/icon.rs
@@ -125,7 +125,9 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
 
     let icon_from_name: std::result::Result<gtk::gdk_pixbuf::Pixbuf, IconError> = (async {
         // fetch icon name
-        let icon_name = match sni.icon_name().await {
+        let icon_name = sni.icon_name().await;
+        log::debug!("dbus: {} icon_name -> {:?}", sni.destination(), icon_name);
+        let icon_name = match icon_name {
             Ok(s) if s == "" => return Err(IconError::NotAvailable),
             Ok(s) => s,
             Err(e) => return Err(IconError::DBusIconName(e)),
@@ -139,7 +141,9 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
         }
 
         // otherwise, fetch icon theme and lookup using icon_from_name
-        let icon_theme_path = match sni.icon_theme_path().await {
+        let icon_theme_path = sni.icon_theme_path().await;
+        log::debug!("dbus: {} icon_theme_path -> {:?}", sni.destination(), icon_theme_path);
+        let icon_theme_path = match icon_theme_path {
             Ok(p) if p == "" => None,
             Ok(p) => Some(p),
             // treat property not existing as the same as it being empty i.e. to use the default
@@ -167,7 +171,9 @@ pub async fn load_icon_from_sni(sni: &dbus::StatusNotifierItemProxy<'_>, size: i
         Err(e) => log::warn!("failed to get icon by name for {}: {}", sni.destination(), e),
     };
 
-    let icon_from_pixmaps = match sni.icon_pixmap().await {
+    let icon_pixmap = sni.icon_pixmap().await;
+    log::debug!("dbus: {} icon_pixmap -> {:?}", sni.destination(), icon_pixmap);
+    let icon_from_pixmaps = match icon_pixmap {
         Ok(ps) => match icon_from_pixmaps(ps, size) {
             Some(p) => Ok(p),
             None => Err(IconError::NotAvailable),
